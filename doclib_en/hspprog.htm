<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta http-equiv="Content-Language" content="en">
	<meta http-equiv="Content-Style-Type" content="text/css">
	<meta http-equiv="Content-Script-Type" content="text/javascript">
	<meta name="author" content="OpenHSP3 Project">
	<meta name="keywords" content="HSP,HSP3Dish,HSP3,HotSoupProcessor,Programming Manual">
	<meta name="description" content="HSP3 Basic Manual">
	<link href="../main.css" rel="stylesheet" type="text/css" media="all">
	<title>HSP3 Programming Manual</title>
</head>
<body>

	<div id="CONTAINER">
		<!-- Header -->
		<p id="COPY"><a id="top" class="head">HSP : Hot Soup Processor ver3.7 / onion software 1997-2025(c)</a></p>
		<img src="hsp3ttl.jpg" alt="title" width="640" height="200">
		<h1>Programming Manual</h1>

		<!-- Table of Contents -->
		<ol>
			<li><a href="#QUICK_START">Quick Start</a></li>
			<li><a href="#GUIDE">Programming Guide</a>
				<ol>
					<li><a href="#FORM">Script Format</a></li>
					<li><a href="#EDIT_EXEC">Script Editing and Execution</a></li>
					<li><a href="#HSP_MECHANISM">HSP Mechanism</a></li>
					<li><a href="#EX_EXPAND">Expanding HSP's Functionality</a></li>
					<li><a href="#HSPEX_PLUGIN">HSP Extension Plugins, Extension Modules</a></li>
					<li><a href="#EX_RUNTIME">Extended Runtime</a></li>
					<li><a href="#GAMEDEV">Game Development with HSP <span class="new">（New!）</span></a></li>
					<li><a href="#ONEKEY_HELP">One-Key Help</a></li>
					<li><a href="#MAKE_EXE">How to Create Executable Files <span class="new">（New!）</span></a></li>
					<li><a href="#MAKE_SAVER">Creating Screen Savers</a></li>
					<li><a href="#START_OPT">Parsing Startup Options</a></li>
					<li><a href="#ICONINS">About Rewriting Executable Files <span class="new">（New!）</span></a></li>
					<li><a href="#SCRIPT_SAMPLE">HSP Script Samples</a></li>
					<li><a href="#HIDDEN_WINDOW">Hidden Main Window EXE Files</a></li>
					<li><a href="#NO_DIR_MOVE">Disabling Directory Movement</a></li>
					<li><a href="#DEBUG_WINDOW">Debug Window</a></li>
					<li><a href="#DEBUG_VARS">Variable Debug Messages <span class="new">（New!）</span></a></li>
					<li><a href="#EX_MACRO">HSP Extended Macros</a></li>
					<li><a href="#COLORING_AND_TAB">Script Coloring and Tab</a></li>
					<li><a href="#EASY_INPUT">Easy Input</a></li>
					<li><a href="#GOTODEFINE">Go to Keyword Definition Function <span class="new">（New!）</span></a></li>
					<li><a href="#ALLREFERENCE">Search All References Function <span class="new">（New!）</span></a></li>
					<li><a href="#LABELLIST">Label List Function <span class="new">（New!）</span></a></li>
					<li><a href="#HSPUTF">About Using UTF8 Compatible Runtime <span class="new">（New!）</span></a></li>
					<li><a href="#HSP64">About Using 64bit(x64) Compatible Runtime</a></li>
					<li><a href="#HSED3CUSTOM">About Script Editor Extension Features</a></li>
					<li><a href="#HSPTV_RESOURCE">About HSPTV Folder Materials <span class="new">（New!）</span></a></li>
				</ol>
			</li>
			<li><a href="#DESCRIPTION">Basics of Script Description</a>
				<ol>
					<li><a href="#DESCRIPTION_RULE">HSP Language Rules</a></li>
					<li><a href="#DESCRIPTION_FORM">Command Format</a></li>
					<li><a href="#PARAMETER">Parameters</a></li>
					<li><a href="#MULTI_STATEMENT">Multi-Statements</a></li>
					<li><a href="#COMMENT">Comments</a></li>
					<li><a href="#EXPRESSION">Expressions</a></li>
					<li><a href="#STRING">Strings</a></li>
					<li><a href="#VAR">Variables</a></li>
					<li><a href="#ARRAY">Array Variables</a></li>
					<li><a href="#FUNC">Functions</a></li>
					<li><a href="#LABEL">Labels <span class="new">（New!）</span></a></li>
					<li><a href="#IF">Conditional Judgment</a></li>
					<li><a href="#REPEAT">Loop Command</a></li>
					<li><a href="#MEM_NOTEPAD">Memory Notepad Command</a></li>
					<li><a href="#SORT">Sort Command</a></li>
					<li><a href="#SYSVAR">System Variables</a></li>
				</ol>
			</li>
			<li><a href="#EX_GRAMMAR">Extended Grammar</a>
				<ol>
					<li><a href="#MODULE">Modules</a></li>
					<li><a href="#USERDEF_COMMAND">User-Defined Commands</a></li>
					<li><a href="#USERDEF_FUNC">User-Defined Functions</a></li>
					<li><a href="#DIFF_FUNC_COMMAND">About the Difference Between Functions and Commands</a></li>
					<li><a href="#MODULEDEF_COMMAND">Module Definition Commands</a></li>
					<li><a href="#PREPROCESSOR">Preprocessor Directives <span class="new">（New!）</span></a></li>
					<li><a href="#DEFINE_MACRO">About #define Macros</a></li>
					<li><a href="#HSPDEF">Standard Macro Definition File</a></li>
					<li><a href="#CALL_API">API Calls</a></li>
					<li><a href="#COM_COMPONENT">COM Component Calls</a></li>
					<li><a href="#AHT">HSP Template (AHT) Function</a></li>
					<li><a href="#VAR_EX">Variable Initialization and Protection <span class="new">（New!）</span></a></li>
					<li><a href="#HSPDEF2">Platform Macro Definition <span class="new">（New!）</span></a></li>
				</ol>
			</li>
			<li><a href="#HSP_BASIS">HSP Basic Operating Concepts</a>
				<ol>
					<li><a href="#TASK">HSP Tasks</a></li>
					<li><a href="#SCR_AND_WND">Screens and Windows</a></li>
					<li><a href="#PRINT">Fonts and Text Display</a></li>
					<li><a href="#IMG_FILE">Using Image Files</a></li>
					<li><a href="#CUR_POSITION">Current Position</a></li>
					<li><a href="#GUI_OBJECT">Placement Objects</a></li>
					<li><a href="#LAYER_OBJECT">Layer Objects</a></li>
					<li><a href="#CUR_COLOR">Current Color</a></li>
					<li><a href="#CEL_FUNCTION">About CEL Related Commands <span class="new">（New!）</span></a></li>
					<li><a href="#INPUT">Acquiring Input <span class="new">（New!）</span></a></li>
					<li><a href="#MEM_BUFFER">Using Memory Buffers</a></li>
					<li><a href="#PLAY_MULTIMEDIA">Multimedia Playback</a></li>
					<li><a href="#VAR_INIT">Detecting Uninitialized Variables <span class="new">（New!）</span></a></li>
					<li><a href="#CONSOLE">Console Version of HSP</a></li>
					<li><a href="#ON_EVENT">Interrupts</a></li>
					<li><a href="#STANDARD_MODNAME">Standard Module Names</a></li>
					<li><a href="#COMMON_DIR">Common Directory</a></li>
					<li><a href="#ERR_MSG">Error Messages</a></li>
					<li><a href="#TOLERANCE_LEVEL">HSP System Tolerance Range</a></li>
					<li><a href="#PACKFILE">File Packing and Encryption <span class="new">（New!）</span></a></li>
					<li><a href="#CNVSRC">Conversion to C Source</a></li>
					<li><a href="#BOOTOPT">About Using Startup Setting #bootopt</a></li>
					<li><a href="#CALLBACK">Callback Routines</a></li>
				</ol>
			</li>
		</ol>

		<!-- Main Content -->
		<h2 id="QUICK_START">Quick Start</h2>
		<p>
			This manual explains the programming methods and language specifications in general for programming on Windows with HSP.
			If you are trying programming for the first time, we recommend that you first read "<a href="beginner/START.HTM">HSP Introduction for Beginners</a>".<br>
			In development environments other than the Windows version, the operation may be different, but the basic syntax and operating mechanism of HSP3 do not change even if the platform is different.
			For details, please refer to <a href="hsp3.htm">HSP3 Overview</a>.
		</p>

		<p>
			If you have some programming experience but are new to HSP,
			we recommend that you read this quick start and actually try using it.
			If you encounter something you don't understand in the process of using it, try searching this manual or using the help browser to find out.
		</p>

		<ul>
			<li>The program list executed by HSP is called a <em>script</em>.
			The editor for editing this is the HSP script editor (hsed3.exe). After starting this and writing a script,
			you can press the [F5] key to execute it.
			Please try executing the attached sample programs.</li>
			<li>In HSP, write the script in the format of "command" + "parameter (can also specify multiple parameters separated by ",")", such as <code>pos a, 10</code>. The commands are executed in order from the first line.
			</li>
			<li>If you move the cursor to a keyword (command) in the HSP script editor and press [F1],
			you can easily refer to the reference using the help browser.</li>
			<li>The basics of commands are similar to BASIC. Assign variables with <code>variable = number</code>, or
			you can specify an expression that mixes numbers and variables as a parameter, such as <code>screen 0, x*64, y</code>.</li>
			<li>Variables can be assigned either numbers or characters. Variable and type declarations are not required.
			Strings are written in a form surrounded by " (double quotation marks), such as <code>a = "string"</code>.
			Only concatenation ("+") is possible for string operations.</li>
			<li>Arrays of variables are specified using parentheses in the form of "variable(element)". In order to use an array,
			declare it in advance with the dim or sdim command.</li>
			<li>goto and gosub commands are provided as basic mechanisms for controlling the flow of the program.
			The labels specified there are defined in the form of "*label name" at the beginning of the line.
			<li>Repetitive descriptions are usually done with the repeat〜loop command. This can be regarded as a simplification of C's for, while, and do.
			In addition, C-language-like macro commands such as while〜wend, do〜until, for〜next, and switch〜case are available.
			For details, please refer to "<a href="#HSPDEF">Standard Macro Definition File</a>".</li>
			<li>In addition to defining commands and defining functions, a mechanism is available for separating namespaces and reusing sources.
			For details, please refer to the "<a href="#MODULE">Modules</a>" section and
			<a href="module.htm">Module Function Guide</a>.</li>
			<li>The created script can be converted into an executable file with [ctrl]+[F9].
			For details, please refer to "<a href="#MAKE_EXE">How to Create Executable Files</a>".</li>
		</ul>


		<h2 id="GUIDE">Programming Guide</h2>
		<h3 id="FORM">Script Format</h3>
		<p>HSP operates based on a program (something that describes commands and the order of execution). The basis of this is the script (source file). This is in the form of a text file, and the extension is .hsp or .as. (The .hsp extension was added from HSP3.0.)
		Scripts can be created with the HSP script editor (HSED3.EXE) included with HSP, or with applications such as text editors.</p>
		<h3 id="EDIT_EXEC">Editing and Executing Scripts</h3>
		<p>Using the HSP script editor (HSED3.EXE), you can easily create, edit, and
		execute HSP scripts. When using the HSP script editor:</p>

		<ol>
			<li>Write the script as text</li>
			<li>Select "Compile + Run" from the menu, or press the F5 function key to execute the script</li>
		</ol>

		<p>With these steps, you can easily execute HSP scripts and verify their operation.</p>

		<p>The HSP script editor (HSED3.EXE) is an editor for HSP script editing. It can automatically perform compilation and execution.
		When using the HSP script editor, the following files must be present in the same directory as HSED3.EXE.</p>

		<dl>
			<dt>HSED3.EXE</dt>
			<dd><p>HSP script editor main program</p></dd>
			<dt>HSED3_EN.EXE</dt>
			<dd><p>HSP script editor main program (English version)</p></dd>
			<dt>HSP3.EXE</dt>
			<dd><p>HSP executable file main program</p></dd>
			<dt>HSP3DEBUG.DLL</dt>
			<dd><p>HSP debug module DLL</p></dd>
			<dt>HSPRT</dt>
			<dd><p>HSP runtime module</p></dd>
			<dt>HSPCMP.DLL</dt>
			<dd><p>HSP code compiler DLL</p></dd>
			<dt>HSPCMP.EXE</dt>
			<dd><p>HSP code compiler (command-line version)</p></dd>
		</dl>
		<p>
			The HSP script editor's main program (HSED3.EXE) and the HSP executable file (HSP3.EXE)
			must be in the same directory.
			Also, to create an executable file (EXE file), the runtime
			file (HSPRT) is also required in the same directory.
		</p>
		<p>
			By launching HSED3_EN.EXE, the menu and other interfaces
			will be in English. There are no changes to the HSP3 main program itself, but if you want to
			use it in an English environment, please try this version.
		</p>
		<p>
			When you launch the HSP script editor, a new text editing window
			is displayed. After that, you can load files or save them like any normal text editor,
			and write HSP scripts.
			The basic operations are almost the same as the "Notepad" program included with Windows.
			You can also select string cut &amp; paste, and search from the menu.
		</p>
		<p>
			To execute the HSP script you are editing, select
			"Compile + Run" from the menu, or press the F5 function key.
			Pressing "Run" or CTRL+F5 will execute the last compiled script.
		</p>
		<p>
			If an error occurs during compilation, a dialog box will appear after compilation
			to inform you of the error content and the line number where the error occurred.
		</p>
		<p><samp>Example: test.hsp(2) : error 7 : Label name already used (line 2)</samp></p>
		<p>
		     The above example shows that a "duplicate label" error occurred on line number 2.
		     If an error occurs, select "Go to Line" (or CTRL+J) from the "Cursor" menu,
		     move to the line where the error occurred, and check its content.
		</p>
		<p>
			A typical way to use it is to create a script while repeating editing and execution in the HSP script editor,
			and when it is completed, use "Create Executable File Automatically" ([Ctrl]+[F9]) from the menu to convert the completed script into
			an EXE file or SCR file (screen saver) to create a single software.
		</p>
		<p>
			The HSP script editor creates the following files during execution.
			These files are only necessary during compilation, so you can
			delete them when the script is completed.
		</p>
		<dl>
			<dt>HSPTMP</dt>
			<dd><p>Temporary file for source script</p></dd>
			<dt>OBJ</dt>
			<dd><p>Temporary file for execution object</p></dd>
		</dl>

		<p>
			You can edit a source script simply by dropping its icon onto the HSED3.EXE icon or into the window.
			Also, if you installed HSP from the installer, you can simply double-click the source script icon (a file with the ".hsp" extension)
			to open the source.
		</p>
		<p>
			After the source script is in the editing state, the directory where the source file is stored
			becomes the current directory.
		</p>


		<h3 id="HSP_MECHANISM">HSP Mechanism</h3>
		<p>
			HSP executes scripts in the following flow.
		</p>
		<dl>
			<dt>Compilation</dt>
			<dd>
				<p>
					Analyzes the source script (text file) with the .hsp extension,
					and creates an object file (AX file) for HSP.<br>
					The script editor (HSED3.EXE) and the code generator (HSPCMP.DLL) perform this work.<br>
					You can automatically start execution by writing a source script in the script editor and pressing [F5].<br>
					To create an object file from the command line, you can use the command-line version of the code compiler (HSPCMP.EXE). For details, see <a href="hspcmp.txt">HSP3 Code Compiler Manual hspcmp.txt</a>.
				</p>
			</dd>
			<dt>Execution</dt>
			<dd>
				<p>Reads the object file (AX file) and executes it.
				(This part is usually performed by the HSP main program (HSP3.EXE))</p>

				<p>The source script is compiled instantly to create an object file.
				The object file stores binary data in a compact and fast-executable format by eliminating unnecessary parts of the source script, such as comments.</p>
				<p>The HSP main program is the core part for reading and executing the specified object file.
				Since this is all done by HSP3.EXE, no other unnecessary DLLs or modules are required.</p>
				<p>If you want to distribute the software you created with HSP, you can create a standalone EXE (executable)
				file. When you create an EXE file,
				the script will run simply by double-clicking the file.
				This is a convenient feature when distributing it as online software or doujin software.</p>
				<p>See "<a href="#MAKE_EXE">How to Create Executable Files</a>" for details.</p>
				<p>You can also execute HSP3.EXE directly from a batch file or command prompt with a file name specified.
				For example, typing <kbd>hsp3 demo.ax</kbd>
				will execute the object file "demo.ax".</p>
				<p>In HSP, there are several extended execution files in addition to HSP3.EXE.
				These are called "HSP Runtimes", and there are several types depending on the application.
				See the "<a href="#EX_RUNTIME">HSP Runtime</a>" section for details.</p>
			</dd>
		</dl>


		<h3 id="EX_EXPAND">Extending HSP's Functionality</h3>
		<p>
			In HSP, you can increase commands and extend functions by using methods such as extension plugins and extension modules. This is a convenient way to easily handle advanced functions, but knowing the mechanism will further expand the range of applications.<br>
			To do so, let's first learn about the mechanism by which the Windows OS executes files.<br>
			I think you all know that double-clicking a file with the .exe extension will start the program.
			Programs and accessories installed on Windows also have .exe files that are ultimately launched.
			On the other hand, there is also the .dll extension. This is a program file that can be loaded in addition to the .exe file after it is launched. It cannot be launched on its own and must be called from another program.
		</p><pre>
			Extension   Content
			---------------------------------------------------
			 .exe    File containing the program to be executed
			 .dll    File containing the program that can be loaded later
		</pre><p>
			Windows has a core part of the OS called the kernel, and that program launches .exe files.
			The launched program provides programs for displaying windows and displaying characters in the form of .dll files. There are many of these available as Windows APIs (Win32API), COM components, or independent libraries (DirectX, OpenGL, etc.).<br>
			Some .dll files are included with Windows from the beginning, while others can be created independently by the user. This is the program extension mechanism built into the Windows OS itself.
		</p>


		<h3 id="HSPEX_PLUGIN">HSP Extension Plugins/Modules</h3>
		<p>
			In HSP, you can add functions in the form of extension plugins and modules.
			This makes it possible to perform processing that cannot be achieved with HSP alone.<br>
			Extension plugins are extension functions that add functions to a program in the form of a DLL (.dll). In HSP, it is possible to call and use not only extension DLLs prepared specifically for HSP, but also DLLs prepared as standard in Windows (Windows API) and DLLs created for C/C++.<br>
			It is also possible to arbitrarily call COM components (ActiveX) to extend Windows functions.
			HSP extension plugins mainly refer to extensions prepared for HSP among extension functions using DLLs.
		</p>
		<p><img src="img/plugin.png"></p> 
		<p> 
			HSP extension modules add functionality to HSP in the same way as extension plugins, but
			The difference is that it is written in HSP itself without using DLLs.
			In either case, by making a determined description on HSP, new commands, functions, etc. are added and the functions can be used.<br>
			The HSP full set includes many plugins and modules.
			See the <a href="plugin.htm">List of Extension Plugins/Modules</a> for details.
		</p>
		<h3 id="EX_RUNTIME">HSP Runtime</h3>
		<p>
			"HSP Runtime" is a mechanism to replace the entire HSP operating system.
			This is for using functions specific to certain applications and systems.<br>
			For example, if you write only "mes "OK"" in the script editor, HSP will operate with the most common instruction set called standard runtime. (This corresponds to HSP3.EXE)
			The HSP runtime is specified in the script by the preprocessor directive "#runtime".
			The specified runtime is reflected during script execution and when creating executable files.
		</p>
		<p><img src="img/runtime.png"></p> 
		<p> 
			In HSP, you may need to change the "HSP Runtime" depending on the application.
			For example, the HSP3Dish runtime only supports instructions that can be multi-platformed,
			and returns an error for other instructions. This allows you to confirm the same behavior as when running on smartphones and tablets.<br>
			It is also possible to select a system that operates on the command prompt without displaying a window, such as the console version of HSP (HSPCL) runtime.
		</p>
		<p>
			The HSP runtime is similar to an "HSP extension plugin" in the sense that it extends or changes HSP's functionality,
			but please consider the "HSP runtime" as something that more deeply replaces the entire HSP functionality.
			The HSP full set includes the following HSP runtimes.
			Please use them as a reference when using them. Please refer to the separate manual for details on each runtime.
		</p>
		<dl>
			<dt>Console version HSP runtime (hsp3cl)</dt>
			<dd>
				<p>
					Used when creating executable files dedicated to console applications.
					Window display and image manipulation are not supported.
				</p>
			</dd>
			<dt>HSP3Dish runtime (hsp3dish)</dt>
			<dd>
				<p>
					Supports only instructions that can be multi-platformed, such as web browsers, smartphones, and tablets.
					In addition to normal drawing instructions, extended instructions are available. In addition, the drawing speed is also improved.
				</p>
			</dd>
			<dt>HGIMG4 runtime (hsp3gp)</dt>
			<dd>
				<p>
					Used when creating executable files for applications created with HGIMG4 runtime.
					Normal drawing instructions cannot be used, and only dedicated instructions provided by HGIMG4 can be used.
					HGIMG4 is backward compatible with HSP3Dish runtime.
				</p>
			</dd>
			<dt>HSP3UTF runtime (hsp3utf)</dt>
			<dd>
				<p>
					It has the same functions as the normal HSP3 runtime, but it is a runtime that processes all strings in Unicode (UTF8) format.
					In addition to handling Unicode format text, it can display a wide range of character codes.
				</p>
			</dd>
			<dt>64bit version HSP3 runtime (hsp3_64)</dt>
			<dd>
				<p>
					It has the same functions as the normal HSP3 runtime, but it is a runtime that runs as a 64bit application.
					Like hsp3utf, all strings are processed in Unicode (UTF8) format.
					It is not compatible with 32bit plugins. We plan to expand 64bit compatible plugins in the future.
				</p>
			</dd>
		</dl>


		<h3 id="GAMEDEV">Game Development with HSP</h3>
		<p>
			HSP can be used for various purposes, but it is most often used for easy game development.
			With reference to the following, you can decide whether to use HSP's extended functions according to the content and purpose of the game.
		</p>
		<dl>
			<dt>General 2D games</dt>
			<dd>
				<p>
				Even with the most common HSP3 standard runtime (without using extended functions), it is possible to create general games.
				Since the HSP3 standard runtime uses only basic Windows APIs, it has high compatibility with a wide range of models and is easy to create. However, the drawing speed is slow and it is not suitable for games that rewrite the screen a lot.<br>
				Many sample scripts are included in the sample/game folder, so please refer to them.<br>
				By adding the hspogg extension plugin separately, detailed control is supported for playing sound effects and music.
				You can also add the OBAQ extension plugin as an easy 2D physics engine.
				</p>
			</dd>
			<dt>Advanced 2D games</dt>
			<dd>
				<p>
				The <a href="hsp3dish_prog.htm">HSP3Dish runtime</a> is available, which allows faster screen rewriting than the HSP3 standard runtime.<br>
				These runtimes can be run on a wide range of environments such as Windows, Android, iOS, Linux, and web browsers.
				Since it uses APIs with GPU support such as DirectX and OpenGL for drawing, there is an advantage that the speed does not drop even when processing a large amount of images.<br>
				In addition, by using the <a href="sprite.html">standard sprite function</a> and the <a href="dotfw.html">Tamane Dot Framework</a>, 2D objects (sprites) can be easily managed, and the number of steps can be greatly reduced.<br>
				The HSP3Dish runtime has some unsupported functions (such as multiple window support) compared to the HSP3 standard runtime, and there are slight differences in the drawing procedure.<br>
				Sample scripts are included in the sample/hsp3dish, sample/sprite, and sample/dotfw folders, so please refer to them.
				</p>
			</dd>
			<dt>3D games</dt>
			<dd>
				<p>
				The HSP3 standard runtime alone often does not have enough functions for games that use 3D display.
				In HSP, HGIMG3 and HGIMG4 are provided as 3D display runtimes. HGIMG3 uses DirectX8, which has been supported for a long time, and new development has now been discontinued.
				Currently, the functions of HGIMG4, which replaces it, are being expanded as needed. Using OpenGL and DirectX, it supports the android, iOS, linux, and html5 platforms, similar to HSP3Dish.<br>
				If you need 3D functions, you can use HGIMG4 to use many modern functions such as FBX format 3D data display, animation playback, 3D physics engine, post effects, and custom shaders.
				However, not all GPUs and graphics cards are supported. If you run it on an old model with Windows 7 or earlier, the phenomenon that it cannot be started or the display becomes strange may occur.<br>
				Sample scripts are included in the sample/hgimg4 and sample/pronama3d folders, so please refer to them.
				</p>
			</dd>
		</dl>

		<h3 id="ONEKEY_HELP">One-Key Help</h3>
		<p>
			The function to call the help of HSP instructions with one button from the string being edited in the script editor is
			"One-Key Help Function".
		</p>
		<p>
			To use it, simply place the caret (cursor position in the editor) on the keyword you want to check and press the [F1] key.
			The description of the corresponding instruction, the meaning of the parameters, etc. will be displayed.
			If there is no help for the keyword, keyword search help in alphabetical order will be displayed.
			This is a useful function when checking what a sample script is doing or when you can't remember the details of an instruction.
		</p>
		<p>
			You can choose from several display methods for one-key help.
			The standard is set to browse help with HSP Help Manager.
		</p>
		<p>
			By default, the Help Manager displays help by specifying keywords in the HSP Docs Library (integrated document viewer).
			These can be set by selecting the "Operation" menu in the "Options" dialog of the HSP script editor.
		</p>

		<p>
			The help data is usually stored in the hsphelp directory under the script editor (HSED3.EXE). If you want to move it to another directory, or if an error occurs when trying to display the help, select the "Directory" menu in the "Options" dialog and reset the help data directory
			(for example, "c:\hsp36\hsphelp").
			If the input is blank, it refers to the HSPHELP directory under HSED3.EXE.
		</p>

		<p>
			For details on "HSP Docs Library" and help files,
			Please refer to "<a href="HSP Docs Library/HDL_Readme.txt">HDL_Readme.txt</a>" and "<a href="HSP Docs Library/HS_BIBLE.txt">HS_BIBLE.txt</a>".
		</p>


		<h3 id="MAKE_EXE">How to create an executable file</h3>
		<p>
			In HSP, you can create an EXE file by putting together the script created by the user and the data files used there.
			Also, an SCR file (screen saver module), which is a type of EXE file, can be created using the same procedure.
		</p>
		<p>
			To convert the file currently being edited into an EXE file from the script editor,
			Select "HSP" → "Automatic Executable File Creation" from the menu,
			Or press "CTRL" + "F9" to create an executable file in the current directory.
			Normally, an executable file named "hsptmp.exe" is generated, but various settings such as the file name can be made by specifying options in the source script.
		</p>
		<p>
			By writing the #pack and #epack instructions in the script, you can embed the files to be used in the executable file.
			In addition, you can collectively embed files in a folder hierarchy into an executable file using the #packdir and #epackdir instructions.
		</p>

		<pre>#pack "file name"            [Specify the file to be packed]
#epack "file name"           [Specify the file to be encrypted and packed]
#packdir "file name"           [Specify the file to be packed together with the folder structure]
#epackdir "file name"           [Specify the file to be encrypted and packed together with the folder structure]</pre>
		<p>
			The specified files are packed together as resources when creating an executable file.
			The difference between #pack and #epack is that #epack encrypts the data before packing it.
		</p>
		<p>
			Files specified with #pack or #epack can be used from the script,
			but they become invisible from the outside. This has the following effects:
		</p>
		<ul>
			<li>Protects image files and other assets used in the game from being extracted.</li>
			<li>Eliminates wasted clusters in each file, reducing disk space.</li>
			<li>Prevents a large number of data files from scattering throughout the directory.</li>
		</ul>

		<p>
			#packdir and #epackdir are formats added from HSP3.7.
			They allow you to pack the structure of the specified folder together.
			(Multiple specifications with folders and wildcards such as "data/*" are possible.)
		</p>

		<p>
			In the following example, the files "a.txt" and "a.bmp" are
			packed together with the executable file, and "a.bmp" is encrypted.
		</p>
		<pre>#pack "a.txt"
#epack "a.bmp"</pre>

		<pre>#packopt Keyword Parameter  [Automatic Creation Option Specification]</pre>
		<p>
			Specifies the behavior of automatic executable file creation.
			After the keyword name, enter a space or TAB and then the parameter
			(for strings, specify like "strings").
			The following keywords can be specified with #packopt:
		</p>

		<table class="keywordlist" summary="Introduces keywords that can be specified with #packopt in a list format.">
			<caption>Keywords that can be specified with #packopt</caption>
			<tr><th>Keyword</th><th>Content</th><th>Initial Value</th></tr>
			<tr><td>name</td><td>Executable file name</td><td>"hsptmp"</td></tr>
			<tr><td>runtime</td><td>Runtime to use</td><td>"hsprt"</td></tr>
			<tr><td>type</td><td>Executable file type</td><td>0</td></tr>
			<tr><td></td><td>(0=EXE file)</td><td></td></tr>
			<tr><td></td><td>(1=Fullscreen EXE)</td><td></td></tr>
			<tr><td></td><td>(2=Screen saver)</td><td></td></tr>
			<tr><td>xsize</td><td>Initial window X size</td><td>640</td></tr>
			<tr><td>ysize</td><td>Initial window Y size</td><td>480</td></tr>
			<tr><td>hide</td><td>Initial window hide SW</td><td>0</td></tr>
			<tr><td>orgpath</td><td>Disable startup directory movement SW</td><td>0</td></tr>
			<tr><td>icon</td><td>Icon file setting</td><td>None</td></tr>
			<tr><td>version</td><td>Version resource setting</td><td>None</td></tr>
			<tr><td>manifest</td><td>Manifest setting</td><td>None</td></tr>
			<tr><td>lang</td><td>Language code setting</td><td>None</td></tr>
			<tr><td>upx</td><td>UPX compression setting</td><td>None</td></tr>
		</table>

		<p>
			The following example creates a screen saver named "test.scr".
		</p>
		<pre>	#packopt type 2
	#packopt name "test"
		</pre>
		<p>
			"start.ax" is added to the packfile with default encryption.
		</p>
		<p>
			If you specify 1 for the "Initial window hide SW" option, the "Initial window hide SW" will be turned ON.
			(For details, please refer to "Hidden Main Window EXE File".)
		</p>
		<p>
			If you specify 1 for the "Disable startup directory movement SW" option, the "Disable startup directory movement SW" will be turned ON.
			(For details, please refer to "About Disabling Directory Movement".)
		</p>

		<p>
			The icon, version, manifest, lang, and upx keywords are set using the iconins tool after the executable file is generated.
			This allows you to embed icons, version information, manifests, etc., into the executable file.<br>
			For more details, please refer to the section "<a href="#ICONINS">About Rewriting Executable Files</a>".
		</p>

		<h3 id="MAKE_SAVER">Creating a Screen Saver</h3>
		<p>
			HSP allows you to create screen saver modules that can be selected from the Windows control panel.
			This involves creating a full-screen display using special commands, and the content drawn there becomes the saver.
			You can create this by making slight modifications to a regular script.
			For details on screen savers, open the "arusave.hsp" file located in the "ssaver" directory
			where the sample files are located.
			It contains instructions on how to write the script, the actual creation procedure, and the sample script itself,
			so please refer to it.
		</p>
		<p>
			With the standard functions, you can create simple screen savers without password protection.
		</p>
		<p>
			There are various conventions for creating screen saver modules (SCR files).
			Please learn them by referring to the sample scripts.
			The window size of the screen saver settings screen (ID0) is fixed to the window size set when creating the screen saver,
			unlike during normal HSP execution.
		</p>

		<h3 id="START_OPT">Parsing Startup Options</h3>
		<p>
			HSP allows you to capture startup options and process them accordingly in the script.
			This makes it possible to call EXEs with various functions from batch files or to handle processing such as
			dropping files onto the EXE file icon.
		</p>
		<p>
			To test this feature from the script editor, there is a "Startup Options..." item in the HSP menu.
			Selecting this allows you to simulate adding startup options even when launching from the script editor.
			To actually check the contents of the startup options in the script,
			use the system variable dir_cmdline. For more information, please refer to the system variable list.
		</p>


		<h3 id="ICONINS">About Rewriting Executable Files</h3>
		<p>
			Normally, when you create an EXE file or SCR file, the icon seen by Windows is the same as HSP3.EXE.
			By preparing a custom icon file, you can freely rewrite the executable file icon for distribution.
			In addition, you can apply version information, manifests, language codes, UPX compression, etc., to the executable file.
		</p>
		<p>
			When performing "Automatic Executable File Creation," it is possible to describe the information to be applied in the source script using the #packopt command.<br>

		A tool is available to support writing the #packopt command.
		Select "Create PACKOPT Item" from the "Tools" menu in the HSP script editor to call the #packopt list creation tool.
		(For details on the #packopt command, please see the help item for the #packopt command.)
		</p>
		<p>
			The icon, version, manifest, lang, and upx keywords specified with the #packopt command use the iconins tool to rewrite the executable file after it is generated.
		</p>
<pre>
	// Specify the icon file to embed
	#packopt icon "test.ico"
	// Specify the file describing the version information to embed
	#packopt version "test.txt"
	// Set "1" to use UPX compression
	#packopt upx "1"
	// Specify the language. The default is Japanese (1041) described in decimal.
	#packopt lang "1041"
</pre>
		<p>
		In the example above, the icon from the "test.ico" icon file is used, and the version information described in the "test.txt" file is set.
		You must specify a file in .ico format for the icon file.<br>
		Also, the language code is set to "1041" (Japanese). This specifies a locale ID described in decimal, such as Japanese (1041) or English (U.S.) (1033). For details on locale IDs, please refer to <a href="https://msdn.microsoft.com/ja-jp/library/cc392381.aspx" target="_blank">here</a>.<br>
		If you specify "1" for UPX compression, UPX executable file compression will be enabled.
		(To use UPX compression, you need to download upx.exe (Win32 console version) in advance and place it in the same folder as the iconins tool.)<br>
		</p>

		<p>
		You need to create a separate text file to set the version information.
		</p>
<pre>
	_FILEVERSION=1.0.0.0
	_PRODUCTVERSION=1.0.0.0
	Comments=Test
	CompanyName=Test!
	FileDescription=Test
	FileVersion=1.00
	InternalName=test
	LegalCopyright=Copyright (C) 2017 Test!
	OriginalFilename=test.exe
	ProductName=Test
	ProductVersion=1.00
</pre>
		<p>
		Describe the content for each required item on each line with "=".
		If you put a ";" (semicolon) at the beginning of the line, that line will be skipped.
		This file is compatible with the version information file of Let's HSPIC! created by <a href="http://lhsp.s206.xrea.com/" target="_blank">Kpan</a>.
		</p>
		<p>
			If you want to change resources over a wider range, please use tools such as <a href="http://www.angusj.com/resourcehacker/" target="_blank">Resource Hacker</a>.
		</p>


		<h3 id="SCRIPT_SAMPLE">HSP Script Samples</h3>
		<p>
			By selecting "View Sample Scripts" from the HSP3 demo title, or
			running "sampview.exe" located in the directory where HSP is installed (e.g., C:\hsp36\),
			you can launch the sample viewer that allows you to browse and execute HSP script samples.
		</p>
		<p>
			HSP includes many samples that can be executed from the script editor.
			It is a good idea to look for a sample that is helpful for your intended use.
			All sample scripts included with HSP can be freely modified and reused.
		</p>

		<h3 id="HIDDEN_WINDOW">Main Window Hidden EXE File</h3>
		<p>
			It is possible to launch an EXE file with the main window hidden at the time of creation.
			With the option set by the #packopt command, if you specify <code>#packopt hide 1</code> and
			create the executable file ([ctrl]+[F9]), the main window (window ID 0) will no longer be displayed when the executable file is launched.
		</p>
		<p>
			This is an option for people who want to prevent the window from appearing in the default position for a moment, even if they change the window size or display position at startup.
			If this option is turned ON, the main window will not be displayed unless you activate the window with a command such as <code>gsel 0,1</code>.
			Try using it when you want to change the position or size of the main window without flickering, or when you want to create an application that does not need to display the main window.
		</p>
		<p>
			Also, even when the main window is hidden, the window exists, so any drawing or object placement performed on the main window will be executed and saved normally.
		</p>

		<h3 id="NO_DIR_MOVE">Disabling Directory Movement</h3>
		<p>
			With the option set by the #packopt command, specifying <code>#packopt orgpath 1</code> when creating an executable file prevents that executable from moving the current directory (working directory) to its own directory upon startup.
		</p>
		<p>
			Normally, this option does not need to be enabled. The usual behavior when starting an executable file is to set the current directory (working directory) to the directory where the started EXE file is located. In other words, the system variables dir_cur and dir_exe are in the same location. Only enable this switch if you have special circumstances, such as wanting to reflect the working folder specified by a shortcut launch, and you do not want to change the current directory at startup.
		</p>
		<p>
			Please note that if you disable directory movement, you must create your script assuming that the system variables dir_cur and dir_exe will not be the same at startup.
		</p>


		<h3 id="DEBUG_WINDOW">Debug Window</h3>
		<img src="img/hsp_dbgw.gif" alt="Debug window screenshot" width="380" height="480" style="float:right;">
		<p>
			A debug window is included to check the state of HSP and the contents of variables during script execution. This can be displayed at all times during execution by turning on the "Show Debug Window" switch in the "HSP" menu of the script editor. Also, even if this switch is not turned on, it will automatically pop up if an error occurs in HSP.
		</p>
		<p>
			Select the display category in the upper left tab of the debug window.
			The selected information will be displayed in the window below.
			The information is as of the time the category was selected. The content
			is not automatically updated, so click the category window again when you want to know information at a different point in time.
		</p>
		<dl>
			<dt>General</dt>
			<dd>
				<p>
					The currently executing line, the state of HSP (execution mode), etc. are displayed.
					System variables, including the nesting level (depth) of gosub and loop, are also displayed.
				</p>
			</dd>
			<dt>Variables</dt>
			<dd>
				<p>
					Displays the contents of defined variables.
					If you check the "Show Array Variables" checkbox, the contents of the array will be
					displayed in a list. Also, by checking the "Variable Dump" checkbox, the contents of the variable buffer will be displayed in hexadecimal.
					The display of variable dumps and arrays may not show everything if the variable has a very large size allocated.
				</p>
				<p>
					If a string-type variable has a string assigned to it that exceeds the buffer capacity,
					a warning message will be displayed. In that case, increase the size of the buffer secured by the sdim command.
				</p>
				<p>
					If "Show Module Variables" is checked, the contents of variables used inside the module will also be displayed.
					Also, if "Sort Display Items" is checked, the variable name list will be sorted alphabetically, making it easier to search.
				</p>
			</dd>
			<dt>Log</dt>
			<dd>
				<p>
					Displays messages sent by the logmes and logmesv commands.
					You can check messages for debugging purposes.
				</p>
			</dd>
			<dt>[Execute] button</dt>
			<dd>
				<p>
					Resumes execution of a script that has been temporarily stopped by the assert command or the [Stop] button.
				</p>
			</dd>
			<dt>[Next Line] button</dt>
			<dd>
				<p>
					Resumes script execution one line at a time from a state temporarily stopped by the assert command or the [Stop] button.
					This allows you to perform step operations to check the execution contents one line at a time.
				</p>
			</dd>
			<dt>[Stop] button</dt>
			<dd>
				<p>
					Temporarily stops the running script.
					It can only be stopped at time-waiting portions such as await and wait commands.
				</p>
			</dd>
		</dl>


		<h3 id="DEBUG_VARS">Variable Debug Messages</h3>
		<p>
			From HSP3.7, it is possible to set variable debug messages using the logmesv command.
			By setting debug messages for specific variables, you can display logs in the debug window.
		</p>
		<pre>
			logmesv VariableName, SettingParameters	; Sets the debug message for the variable
		</pre>
		<p>
		The logmesv command specifies the variable to be set and sets the details with the setting parameters. If the setting parameter is 1 or omitted, the display of the debug message is enabled. In this case, element 1 and later of the array variable will not be displayed.<br>
If setting parameter 2 is set, the display of debug messages is enabled for all elements of the array variable.
		</p>
		<pre>
			Example :
				logmesv a		; A debug message is displayed when variable a is assigned
		</pre>
		<p>
		In the example above, debug message display is set for variable a.<br>
		Debug messages are recorded when the contents of a variable with debug message display set are changed, such as by assignment.
		Variable debug messages are displayed as follows.
		</p>
		<pre>
			Example :
				#set[a=0] line:17 (test_logmes.hsp)
				#set[b=456] line:22 (test_logmes.hsp)
				#set[b(1)=123] line:22 (test_logmes.hsp)
				#set[b(2)=789] line:22 (test_logmes.hsp)
				#set[c="abcdefgh..."] line:23 (test_logmes.hsp)
		</pre>
		<p>
		"#set" is followed by "variable name=content". The content display is only a simple one. Only the first 16 characters of a string are displayed.<br>
		Array variables are displayed as "variable name(element)", but note that array elements of 2 or more dimensions are treated as 1 dimension.<br>
		At the end, information is recorded in the form of "line:line number (script file)", indicating which line and script file the value was set in.<br>
		Variable debug messages allow you to check for mistakes such as content being unintentionally changed within the script, or not being assigned correctly.<br>
		To display the debug window, you need to set the debug window display mode from the script editor, or display the debug window using the assert command.
Please note that the logmesv command is disabled in scripts converted to executable files, or in platform-converted environments (iOS, Android).
		</p>



		<h3 id="EX_MACRO">HSP Extended Macros</h3>
		<p>
			HSP extended macros are a set of macro definitions that are supported as standard,
			and the "hspdef.as" file in the common folder performs the settings.
			When compiling a script, "hspdef.as" will be automatically read.
		</p>
		<p>
			Various extended macros and modules are available, so you can use them explicitly using the "#include" or "#use" command.
			For example, if you write "#include "hsp261cmp.as"", it will operate as HSP2.61 compatible.
		</p>

		<h3 id="COLORING_AND_TAB">Script Coloring and Tabs</h3>
		<p>
			The HSP script editor (HSED3.EXE) supports keyword coloring and editing multiple files using tab switching.
			By default, keywords are colored according to the following conditions.
		</p>
		<table class="keywordlist" summary="This table introduces the types of keywords that the script editor colors and their colors in a list format.">
			<caption>List of keywords colored by the script editor</caption>
			<tr><th>Keyword Type</th><th>Color</th></tr>
			<tr><td>Comment</td><td>Yellow-green</td></tr>
			<tr><td>Command/Function/System Variable</td><td>Light blue</td></tr>
			<tr><td>Preprocessor command</td><td>Light blue</td></tr>
			<tr><td>String</td><td>White</td></tr>
			<tr><td>Label Definition</td><td>Yellow</td></tr>
			<tr><td>Macro</td><td>Dark green</td></tr>
			<tr><td>Other</td><td>White</td></tr>
		</table>
		<p>
			The user can change the color of keywords and the background in the options settings dialog.
			It is also possible to read multiple files and edit them while switching between tabs.
			You can switch between the files you are editing by clicking directly on the tab or by using the "Window" menu.
		</p>


		<h3 id="EASY_INPUT">Easy Input</h3>
		<p>
			The <em>Easy Input</em> item is available in the right-click menu of the script editor.
			This is an assist function for beginners that allows you to select the content of the function you want to use, and then select parameters and options using a separate dialog user interface.
		</p>
		<p>
			Easy Input can also be called from within the HSP Assistant, which starts at the same time as the script editor. For details, please refer to the <a href="hspat.htm">HSP Assistant Manual</a>.
		</p>
		<p>
			For example, if you select the "Specify Color" function, a dialog will appear where you can enter the color to specify in R, G, B, or hexadecimal, or
			you can specify it from a color sample.
			By entering the color you want to specify in the dialog and pressing the "OK" button,
			the script is automatically generated at the cursor position in the script editor.
			"Easy Input" helps you when you don't know the keyword for the function you want to use, or
			when you need to enter parameters that are not intuitive, such as font names or color codes.
		</p>
		<p>
			The "Easy Input" function is based on the HSP Template Tool (AHT). The dialogs displayed in "Easy Input" and the contents of the generated source
			are all defined by the AHT files (files with the extension ".aht") in the "ezinput" folder. By creating this file yourself,
			you can freely customize the items available in "Easy Input".
			For more details about AHT files, please refer to "aht.txt" in the doclib folder.
		</p>
		<p>
			Also included is the module "mod_aht.as", which serves as the base for constructing "Easy Input" and "AHT Manager".
			By using "mod_aht.as", you can easily edit and refer to the contents of AHT files.
			For details on AHT, please refer to the separate document aht.txt.
		</p>


		<h3 id="GOTODEFINE">Go to Definition Function</h3>
		<p>
			From HSP3.7, a <em>Go to Definition</em> item is available in the script editor's right-click menu.
			This function also works by pressing the [F12] key.<br>
			This is a function that searches for and jumps to the original location where the keyword at the cursor position is defined.
		</p>
		<p><center><img src="image/hsed37_4.png" width="720"></center></p>
		<p>
			For example, if a label is specified like "goto *main", you can jump to the location where "*main" is defined by placing the cursor on "*main" and selecting "Go to Definition".<br>
			Similarly, for variables, it jumps to the location where they are initialized, and for macros and user-defined commands/functions, it jumps to the location where they are defined.<br>
			This automatically reads the definition location within files, even when referring to other files using "#include" or "#use" commands.
			If the corresponding keyword does not exist, or if it is a command or macro defined by HSP as standard, it will be ignored because there is no definition location.
		</p>

		<h3 id="ALLREFERENCE">Find All References Function</h3>
		<p>
			From HSP3.7, a <em>Find All References</em> item is available in the script editor's right-click menu.
			This function also works by pressing the [Shift]+[F12] keys.<br>
			This searches for all locations where the keyword at the cursor position is used and creates a list. You can also jump to any location from the list.<br>
			By checking the "Include External Files" checkbox, you can include items referring to other files using "#include" or "#use" commands in the search.
		</p>
		<p><center><img src="image/hsed37_2.png" width="720"></center></p>
		<p>
			The list displays four elements: the line number indicating the corresponding location, the type, the keyword, and the script file name.
			The type indicates the classification of the searched keyword, such as whether it is a variable or a label.
		</p>
		<table class="keywordlist" summary="A list of keyword types that the script editor color-codes and their colors.">
			<caption>Keyword Type List</caption>
			<tr><th>Type</th><th>Content</th></tr>
			<tr><td>dfnc</td><td>User-defined command/function</td></tr>
			<tr><td>dmac</td><td>Macro</td></tr>
			<tr><td>dlab</td><td>Label</td></tr>
			<tr><td>dvar</td><td>Variable</td></tr>
			<tr><td>dexv</td><td>Special variable</td></tr>
			<tr><td>dcmd</td><td>Standard command</td></tr>
			<tr><td>dexc</td><td>Extension command</td></tr>
			<tr><td>rfnc</td><td>User-defined command/function (reference)</td></tr>
			<tr><td>rmac</td><td>Macro (reference)</td></tr>
			<tr><td>rlab</td><td>Label (reference)</td></tr>
			<tr><td>rvar</td><td>Variable (reference)</td></tr>
			<tr><td>rexv</td><td>Special variable (reference)</td></tr>
			<tr><td>rcmd</td><td>Standard command (reference)</td></tr>
			<tr><td>rexc</td><td>Extension command (reference)</td></tr>
		</table>
		<p>
		The part where the keyword is referenced is indicated in the format "-> keyword".<br>
		The function to find all references is extracted by analyzing the script being edited. Therefore, please note that if there are fatal errors in the script or incomplete lines, they will not be extracted correctly.
		For details on searching for the location where a variable is initialized, refer to <a href="#VAR_INIT">"Uninitialized Variable Detection"</a>.
		</p>

		<h3 id="LABELLIST">Label List Function</h3>
		<p>
			From HSP3.7, the <em>Label List</em> item in the script editor's "Cursor" menu has been updated. This function also works by pressing the [F11] key.<br>
			By selecting Label List, a list of labels and user-defined commands/functions included in the currently edited script is displayed in a list box, and you can directly jump to the corresponding line by selecting an arbitrary label.<br>
			By checking the "Include External Files" checkbox, you can include items referring to other files using "#include" or "#use" commands in the search.
			This is a useful function when the script becomes large and inconvenient to move around, or when you forget where you put the label.
		</p>
		<p><center><img src="image/hsed37_3.png"></center></p>
		<p>
			The content of the displayed information is the same as <a href="#ALLREFERENCE">"Find All References Function"</a>.
		</p>

		<h3 id="HSPUTF">About Using the UTF8 Compatible Runtime</h3>
		<p>
			The HSP3UTF runtime (hsp3utf.exe) for operating the standard HSP3 runtime on a unicode(UTF-8) character base is included.<BR>
			It has the same functions as the normal HSP3 runtime, but only the handling of strings is unicode(UTF-8).
			We plan to continue to improve it as a new HSP3 that can handle characters that cannot be expressed by standard HSP that handles SJIS character code.
			To use it, specify the following line at the beginning of the script.
		</p>
		<pre>
			#include "hsp3utf.as"
		</pre>
		<p>
			For details, please see the document <a href="hsp3utf.txt">hsp3utf.txt</a>.<br>
			In the UTF8 compatible runtime, it is possible to use unicode(UTF-8) strings in the source script.
			However, since the standard HSP script editor currently only handles SJIS character code, it cannot be used as is.<br>
			Extensions such as "language-hsp3 for VSCode" for using HSP3 from VSCode, and "HSP3 GINGER" for developing HSP3 from external editors have been released.
			In addition, an HSP script editor based on Sakura Editor by inovia has been developed. By using these, it is possible to execute source scripts written in UTF8 code as is.
		</p>
		<pre>
			language-hsp3 for VSCode
			<a href="https://marketplace.visualstudio.com/items?itemName=honobonosun.language-hsp3" target="_blank">https://marketplace.visualstudio.com/items?itemName=honobonosun.language-hsp3</a>

			HSP3 GINGER
			<a href="https://github.com/vain0x/hsp3-ginger" target="_blank">https://github.com/vain0x/hsp3-ginger</a>

			HSP Script Editor Powered by Sakura Editor Alpha version 1
			<a href="https://hsp.moe/hsed3s/alpha1/" target="_blank">https://hsp.moe/hsed3s/alpha1/</a>
		</pre>
		<p>
		</p>


		<h3 id="HSP64">About Using the 64bit(x64) Compatible Runtime</h3>
		<p>
			The HSP3 standard runtime (hsp3_64.exe) that operates as a 64bit(x64) app is included.
			To use it, specify the following line at the beginning of the script.
		</p>
		<pre>
			#include "hsp3_64.as"
		</pre>
		<p>
			The 64bit(x64) runtime only works on 64bit versions of Windows.
			Please consider the included version as a β test version for future 64bit support.
			Normally, there is no problem using the standard 32bit version of the HSP3 runtime (hsp3.exe).
			<br><br>
			Currently, there are the following notes for the 64bit runtime.
		</p>
		<ul>
			<li>This is a runtime that allows traditional HSP scripts to run as 64bit apps.
			　(The range of integer values and other traditional specifications do not change)
			<li>The memory buffer used by one variable is limited to 2GB (32bit)
			　(The memory size that the entire script can use conforms to 64bit apps)
			<li>Character code is treated as UTF8 (same as hsp3utf)
			<li>Not compatible with traditional 32bit plugins
			<li>COM-related commands may not work correctly
			<li>Does not support rewriting icons with the #packopt command
		</ul>


		<h3 id="HSED3CUSTOM">About Script Editor Extension Functions</h3>
		<p>
			From HSP3.51, extension functions from the modified version of the HSP3 script editor (implemented by inovia and Tetr@pod) have been incorporated.<br>
			The following functions have been added.
		</p>
		<ul>
			<li>Custom keyword color coding function
			<li>Automatic file backup function
			<li>Support for fonts that could not be set traditionally, such as proportional fonts
			<li>Window splitting function
			<li>Background image display function
			<li>Movement by double-clicking labels (link label)
			<li>User-defined command/function color coding function
			<li>Faster replacement function
		</ul>
		<p>
			The extended functions can be turned ON/OFF in the "Tools" → "Options" menu items.<br>
			To use the link label function, check "Use link label" in the "Editor" → "Color" item in the options. After that, the labels in the script will be color-coded, and you can move to the defined label by double-clicking it.<br>
			With the background image display function, you can always display the specified image in the lower right corner of the editor background. You can set it in the "Editor" → "Color" item in the options.<br>
			The automatic file backup function can be set from "General" → "Operation" in the options. By creating a backup of the file being edited at regular intervals, you will not lose the script in the event of unexpected events such as forced termination or reset. (Backups are created in the "backup" folder in the HSP installation folder.)
		</p>


		<h3 id="HSPTV_RESOURCE">About HSPTV Folder Materials</h3>
		<p>
		"HSPTV Folder Materials" are image and sound material data prepared in advance by HSP.
		This material is contained in the "hsptv" folder under the folder where HSP is installed.
		For example, "bg01.jpg" which can be used as a background material, and "se_bom.wav" which can be used as a sound effect are included.<br>
		In HSP, you can freely refer to and use the data in this folder.
		</p>
		<pre>
			celload "bg01.jpg",1	; Use HSPTV folder material
		</pre>
		<p>
		You can load materials by writing the filename located in "HSPTV folder material" without specifying the folder name.
		You can also explicitly specify the folder by using the macro "dir_tv" that indicates the HSPTV folder, like "celload dir_tv+"bg01.jpg"".<br>
		When creating and distributing an executable file, add the necessary materials using the #pack or #epack command, and then perform "Create Executable Automatically".
		</p>
		<pre>
			#pack "bg01.jpg"
		</pre>
		<p>
		In the example above, the "bg01.jpg" file is embedded when creating the executable file and used.
		</p>
		<p>
		For details on HSPTV folder materials, please refer to the separate document <a href="hsptv_res.htm">hsptv_res.htm</a>.
		</p>




		<h2 id="DESCRIPTION">Basic Grammar</h2>
		<h3 id="DESCRIPTION_RULE">HSP Language Rules</h3>
		<p>
			In HSP, grammar is broadly divided into two categories.
		</p>
		<dl>
			<dt>Basic Grammar</dt>
			<dd>
				<p>
					The minimum grammar required for creating programs.
					For beginners or when creating small programs, it is fine to only use the basic grammar.
				</p>
			</dd>
			<dt>Extended Grammar</dt>
			<dd>
				<p>
					Grammar including mechanisms for extending HSP's functionality.
					Necessary when providing functionality to other users or creating large-scale programs.
					Beginners can get by without specifically learning extended grammar.
					Intermediate and advanced users are encouraged to master extended grammar to step up their skills.
				</p>
			</dd>
		</dl>
		<p>
			This document explains the detailed specifications of both basic and extended grammar.
		</p>

		<h3 id="DESCRIPTION_FORM">Command Format</h3>
		<p>
			A script is a text file that summarizes the order in which processes are performed and what processes are performed.  An instruction (statement) indicates what kind of processing to perform.
		</p>
		<p>
			As with BASIC and C, instructions are executed sequentially from the first line of the file downwards.
		</p>
		<p>
			Instructions (statements) control the flow of the program and perform input/output with screens, files, and the like.
			There are many instructions, such as program control instructions and input/output control instructions.
			Scripts are case-insensitive. You can write them in either uppercase or lowercase.
		</p>
		<pre>; Example:
	randomize</pre>
		<p>
			In the example above, the randomize instruction is executed.
			Instructions often have parameters attached to specify the execution content in detail.
		</p>


		<h3 id="PARAMETER">Parameters</h3>
		<p>
			In HSP, the basic format is to add parameters after the instruction.
			It is necessary to leave a space between the instruction and the parameters added to the instruction. Also, if there are multiple parameters, separate them with ", (comma)".
		</p>
		<p>
			For example, the script <code>width 640,480</code> means that
			"width" is the instruction (statement), and the numerical values 640 and 480 are the parameters.
			This combination means "set the window size to 640x480".
		</p>
		<p>
			In the "Instruction Reference" section of the documentation file, if it says:
		</p>
		<pre class="quote">statement p1,p2

p1=0〜3(1)
p2=0〜65535(0)</pre>
		<p>
			it means that this instruction can specify two parameters, p1 and p2.
			It shows that the possible values for p1 are from 0 to 3, with the default value being 1, and the possible values for p2 are from 0 to 65535, with the default value being 0.
		</p>
		<p>
			You can also omit parameters. In the example above, you can omit the value of p2 and write <code>statement 3</code>,
			which is the same as writing <code>statement 3,0</code>, with the omitted value automatically set.
		</p>
		<p>
			If you want to omit only part of the parameters, you can skip the omitted parameter and specify another parameter like <code>statement ,100</code>.
			In this case, it is the same as writing <code>statement 1,100</code>.
			The default values vary for each instruction.
		</p>
		<p>
			Even if you only write <code>statement</code> and do not specify any parameters,
			the values "1,0" are automatically set. Basically, parameters are arranged in order of importance, so it is rare to omit them all. Also, parameters that specify strings or parameters that must be variable names may not be omittable.
		</p>


		<h3 id="MULTI_STATEMENT">Multi-Statements</h3>
		<p>
			It is also possible to write multiple instructions on one line by separating them with : (half-width colon).
			This is called a multi-statement. For example,
		</p>
		<pre>; Example:
    mes "Hello" : mes "Goodbye"</pre>
		<p>
			is the same as writing
		</p>
		<pre>    mes "Hello"
    mes "Goodbye"</pre>
		<p>
			You can write multiple instructions on one line like this.
			There is no limit to the length of a line, but it is better to keep it to a length that is easy to see in a text editor.
		</p>

		<h3 id="COMMENT">Comments</h3>
		<p>
			In a line, anything after ; (half-width semicolon) is treated as a comment and ignored.
		</p>
		<pre>; Example
    pos 320,100 : mes "(^_^)"        ; Display face mark</pre>
		<p>
			Comment descriptions similar to C and Java are possible.
			In a line, anything after // (double slash) is treated as a comment and ignored.
			Everything between "/*" and "*/" is treated as a comment and ignored.
		</p>
		<pre>; Example
    pos 320,100 : mes "(^_^;)"        // Display face mark
    /* This is a comment */ goto *start</pre>
		<p>
			Spaces and tabs can be freely inserted to make the code easier to read.
			(By default, full-width spaces are also treated as spaces.)
		</p>

		<h3 id="EXPRESSION">Expressions</h3>
		<!-- Revised the expression to "data and operators" instead of just "operators". 08/01/26 eller -->
		<p>
			In places where you specify parameters for instructions, you can write expressions including data and operators as shown below.
		</p>
		<table class="keywordlist" summary="Introduces the data available in HSP in a list format.">
			<caption>Data available in HSP - List</caption>
			<tr><th>Data</th><th>Type</th></tr>
			<tr><td>-2147483648〜2147483647</td><td>Decimal integer (32-bit)</td></tr>
			<tr><td>-???.???〜???.???</td><td>Decimal real number (64-bit double precision)</td></tr>
			<tr><td>$0〜$FFFFFFFF</td><td rowspan="2">Hexadecimal integer</td></tr>
			<tr><td>0x0〜0xffffffff</td></tr>
			<tr><td>%0〜%111111...</td><td rowspan="2">Binary integer</td></tr>
			<tr><td>0b0〜0b111111...</td></tr>
			<tr><td>'A'</td><td>Character code (8-bit integer value)</td></tr>
			<tr><td>"String"</td><td>String</td></tr>
			<tr><td>Variable</td><td>Keyword to hold a value</td></tr>
			<tr><td>Function</td><td>Keyword to convert a value</td></tr>
		</table>
		<table class="keywordlist" summary="Introduces the operators available in HSP in a list format.">
		<caption>Operators available in HSP - List</caption>
			<tr><th>Operator</th><th>Type</th></tr>
			<tr><td>+,-,*,/</td><td>Addition, Subtraction, Multiplication, Division</td></tr>
			<tr><td>&amp;,|,^</td><td>Logical operation (and,or,xor)</td></tr>
			<tr><td>\</td><td>Remainder of division</td></tr>
			<tr><td>=,&lt;,&gt;,!</td><td>Conditional expression (equal, less than, greater than, not equal)</td></tr>
			<tr><td>==,&lt;=,&gt;=,!=</td><td>Conditional expression 2 (equal, less than or equal to, greater than or equal to, not equal)</td></tr>
			<tr><td>&lt;&lt;,&gt;&gt;</td><td>Bit shift to the left and right</td></tr>
		</table>
		<p>
			For example, <code>statement 1+2+3+4</code> is the same as writing <code>statement 10</code>. This is called a <em>mathematical expression</em>.
		</p>
		<p>
			The evaluation of mathematical expressions is performed in descending order of precedence.
			For example, <code>2+7*2</code> becomes 16.
		</p>
		<p>
			In expression evaluation, the operators with higher precedence among the following operators take precedence.
		</p>
		<table class="keywordlist" summary="Introduces operator precedence in a list format.">
			<caption>Operator precedence</caption>
			<tr><th>Operator</th><th>Precedence</th></tr>
			<tr><td>* /</td><td>4 (High)</td></tr>
			<tr><td>+ -</td><td>3</td></tr>
			<tr><td>Comparison operator</td><td>2</td></tr>
			<tr><td>&amp; | ^</td><td>1 (Low)</td></tr>
		</table>
		<p>
			If you want to change the order of calculation, you can use parentheses and write <code>(2+7)*2</code>,
			in which case 2+7 in parentheses is calculated first, and the result is 18.
		</p>
		<p>
			Conditional expressions and logical operations are used in conditional judgments, which will be explained later.
		</p>
		<p>
			Parentheses can be used in multiple nested levels. If the parentheses are used incorrectly,
			an error (priority error) is displayed. Also, you can use functions to process the input values in the expression.
		</p>
		<p>
			It is also possible to write expressions that mix integers, real numbers, strings, and functions.
			In that case, the subsequent terms are type-converted to match the first term to be calculated.
			For example, in the calculation "8 + 4.5", 4.5 is treated as 4 (integer) to match the first 8 (integer).
			Conversely, in the case of "4.5 + 8", it is matched to 4.5 (real number), and the calculation result is 12.5.
		</p>
		<p>
			Whether a numerical value is an integer or a real number is determined by whether or not it has a decimal point.
			When performing operations with real numbers, it is necessary to explicitly include a decimal point, such as "8.0 + 4.5".
			It is also possible to express real numbers with large digits by specifying the exponent part following "e", such as "1.0e+10".
			However, please note that handling real numbers has a higher memory efficiency and speed cost compared to integer values.
		</p>
		<p>
			Characters enclosed in ' (single quotation marks) are interpreted as integer values indicating character codes.
			Even if you specify a long string or a full-width character, only the first byte is interpreted as a code.
		</p>
		<p>
			In the case of <code>'A'</code>, it represents the character code (65) for "A".
			At that time, you can write special codes using the "\" symbol (such as "\n") as with strings.
			To indicate the character code of "'" itself, specify <code>'\''</code>.
			Also, to indicate the character code of "\", specify <code>'\\'</code>.
		</p>


		<h3 id="STRING">String</h3>
		<p>
			In places where you specify a string as a parameter of a command, you can write a string by enclosing it in " (double quotation marks).
		</p>
		<pre>; Example:
    mes "This is test message..."</pre>
		<p>
			You can use "+" to combine strings with each other or with variables.
			For example, <code>"ABCD"+"EFGH"</code> is the same as <code>"ABCDEFGH"</code>.
			<code>"VALUE="+val</code> is <code>"VALUE=5"</code> (if the variable val is 5).
		</p>
		<p>
			"\" is interpreted as a character with a special meaning.
		</p>
		<ul>
			<li>"\n" means to start a new line.</li>
			<li>"\t" represents the TAB code.</li>
			<li>"\r" represents the return code (0x0d).</li>
			<li>"\"" represents a double quote (").</li>
			<li>"\\" is just a "\".</li>
		</ul>
		<p>
			Therefore, a string to indicate a directory, such as <code>"C:\WINDOWS\SYSTEM"</code>,
			will not be recognized unless it is written as <code>"C:\\WINDOWS\\SYSTEM"</code>.
		</p>
		<p>
			It is also possible to write long strings that do not fit on one line collectively.
		</p>
			<pre>    mes {"
    Here, you can write a message directly
    on the entire line.
"}</pre>
		<p>
			In this way, everything between "{" and "}" is interpreted as a string.
			When spanning multiple lines, a line feed code is inserted at the end of each line.
		</p>

		<p>
			HSP has many commands and functions for handling strings.
		</p>
		<table class="keywordlist" summary="Introduces commands and functions for handling strings in a list format.">
		<caption>List of commands and functions for handling strings</caption>
			<tr><th>Keyword</th><th>Function</th></tr>
			<tr><td>getstr</td><td>Read string from buffer</td></tr>
			<tr><td>strmid</td><td>Extract part of string</td></tr>
			<tr><td>instr</td><td>Search for string</td></tr>
			<tr><td>getpath</td><td>Get part of path</td></tr>
			<tr><td>strf</td><td>Convert to formatted string</td></tr>
			<tr><td>cnvwtos</td><td>Convert unicode to normal string</td></tr>
			<tr><td>cnvstow</td><td>Convert normal string to unicode</td></tr>
			<tr><td>strtrim</td><td>Remove only specified characters</td></tr>
			<tr><td>split</td><td>Assign elements split from string</td></tr>
			<tr><td>noteadd</td><td>Add/change specified line</td></tr>
			<tr><td>notedel</td><td>Delete line</td></tr>
			<tr><td>noteget</td><td>Read specified line</td></tr>
			<tr><td>noteinfo</td><td>Get memory notepad information</td></tr>
			<tr><td>notesel</td><td>Memory notepad setting</td></tr>
			<tr><td>noteunsel</td><td>Restore target buffer</td></tr>
			<tr><td>notesave</td><td>Save target buffer</td></tr>
			<tr><td>noteload</td><td>Load target buffer</td></tr>
		</table>
		<p>
			In addition, many support is provided by extension plugins and modules.
		</p>


		<h3 id="VAR">Variable</h3>
		<p>
			You can handle variables with arbitrary names. A variable is like a container whose contents can be changed by assignment.
		</p>
		<p>
			Variables are identified by strings of 59 characters or less (single-byte) starting with an alphabet or Japanese.
			Variables can store various information such as numbers and strings by assignment.
			Also, you can use array variables to store multiple pieces of information in one variable by adding an index.
		</p>
		<p>
			The range that can be stored as a numerical value is the same as the value that can be specified in a formula, from -2147483648 to 2147483647, which is a 32-bit integer value,
			or a real value (64-bit double precision).
		</p>
		<p>
			Variables cannot use the same name as labels or commands. Variables can be used in assignment commands and formulas.
		</p>
		<p>
			The assignment command is as follows.
		</p>
		<pre>; Example
    x=100                ; Assign the number 100 to variable x
    y=200                ; Assign the number 200 to variable y</pre>
		<p>
			If used as a numeric specification for a command,
		</p>
		<pre>; Example
    x=100:y=200:pos x,y        ; Move to (100,200)</pre>
		<p>
			It will be like this.
			When a value is assigned to a variable, the previously stored value is erased and a new
			value is retained.
			The same applies when assigning a string to a variable:
		</p>
		<pre>; Example
    x="strings"      ; Assign the string "strings" to the variable x
    mes x            ; Display the contents of variable x on the screen</pre>
		<p>
			Assignment memorizes the number if the thing after "=" is a number, and the string if it is a string. Variables have several states, such as a string type if the thing being stored is a string,
			a numeric type if it is a number, and a real number type if it is a real number (decimal).
		</p>
		<p>
			Be careful because if you specify a string-type variable for a command that requires a number as a parameter,
			or if you specify a numeric-type variable for a command that requires a string as a parameter,
			a "Type mismatch" error will occur.
		</p>
		<p>
			There are some special assignment commands. "Variable" + "Operator" + "=" + "Parameter"
			performs the calculation of the specified operator and parameter on the original variable.
		</p>
		<pre>; Example
    a=10        ; Assign 10 to variable a
    a+=2        ; Add 2 to variable a (same as a=a+2)</pre>
		<p>
			In the above example, variable a will have the value 12.
			In this way, using "+=" adds everything after "+=" to variable a itself.
			Similarly, all operators such as "-=" and "*=" can be used.
			(Also, the same operation is performed by omitting "=" and using the format "Variable" + "Operator" + "Parameter".
			However, this format is not recommended because it is not compatible with languages such as C and Java.)
		</p>
		<p>
			Simple addition and subtraction can also be performed using the following format.
		</p>
		<pre>; Example
    a+            ; Add 1 to variable a
    a-            ; Subtract 1 from variable a</pre>
		<p>
			By adding "+" or "-" to "Variable", +1 and -1 are executed.
			(The same result can be obtained with the C and Java compatible formats a++ and a--. However, it cannot be used in expressions.)
		</p>
		<p>
			To specify the type of variable, you can forcibly change the type of variable. The functions for that are int and str.
		</p>
		<pre>; Example
    a=int(a)    ; Set variable a to numeric type
    b=str(b)    ; Set variable b to string type
    c=double(c) ; Set variable c to real number type</pre>
		<p>
			Even if you change the type of variable, it will try to retain its contents as much as possible.
		</p>
		<p>
			If you change a variable containing the string "123" to a numeric type, it will become the number 123,
			and conversely, if you change a numeric type variable with the number 123 to a string type, it will be converted to the string "123".
		</p>
		<p>
			When using variables, be sure to initialize their contents in advance.
			If you read a value without initializing it, it will be treated as 0 (integer value). See <a href="#VAR_EX">"Variable Initialization and Protection"</a> for details.
		</p>


		
		<h3 id="ARRAY">Array Variable</h3>
		<p>
			Using array variables allows you to manage a large amount of data by numbering what you want to store in a variable.
		</p>
		<p>
			Normally, only one number or string can be stored in variable a.
			However, if you use an array variable, you can store multiple numbers or strings in it.
			Array variables are used as follows.
		</p>
		<pre>; Example
    a(0)=10        ; Assign 10 to element 0 of variable a
    a(1)=20        ; Assign 20 to element 1 of variable a
    a(2)=30        ; Assign 30 to element 2 of variable a</pre>
		<p>
			Add parentheses after the variable and specify a number with a numeric value.
			This number is called the "element of the array" and specifies where in the variable it is stored.
			The element usually specifies an integer value starting from 0.
		</p>
		<p>
			The elements of the array variable are automatically secured when they are assigned.
			For example, if you write <code>a(2)=5</code>, a(2) will be automatically secured and
			the value 5 is assigned. However, if you write <code>a(1000)=0</code>,
			all elements from a(0) to a(1000) will be secured in memory, so
			be careful to use the element numbers in order from 0.
		</p>
		<p>
			Also, array elements are only secured at the time of assignment, so
			if you write <code>a=b(10)</code>, and element 10 is not secured in array variable b,
			be careful because an error will occur.
			Note that you cannot extend the dimension with automatic array element allocation.
		</p>
		<p>
			If you want to secure array elements in advance, use the dim command.
		</p>
		<pre>; Example
    dim a,20    ; The elements of variable a can be used from 0 to 19</pre>
		<p>
			You can also create multidimensional arrays using the dim command.
		</p>
		<pre>; Example
    dim a,10,5  ; Variable a can use a 2-dimensional array
    a(0,0)=1    ; Assign 1 to element (0,0)
    a(1,0)=2    ; Assign 2 to element (1,0)
    a(0,1)=3    ; Assign 3 to element (0,1)</pre>
		<p>
			In this case, specify the elements using two "," (commas) like "variable name (first element, second element)".
			Similarly, you can create arrays up to 4 dimensions using the dim command.
		</p>
		<pre>; Example
    a("test")=10        ; Assign 10 to the element "test" of variable a
    a(5.5)=20           ; Assign 20 to the element 5.5 of variable a</pre>
		<p>
			Since it is the same variable even if the element changes, you cannot mix the types of variables for each element.
			If variable a is a string type, all elements will also be string types. The same applies to numeric types.
		</p>
		<pre>; Example
    a(0)=0
    a(10)="string"        ; This will cause an error</pre>
		<p>
			There is also another notation for array variables.
		</p>
		<pre>; Example
    a.5=123        ; Assign 123 to element 5 of variable a</pre>
		<p>
			This format is compatible with HSP ver2 and earlier. "a.5" has the same meaning as "a(5)".
			For multi-dimensional arrays, separate with "." (period) like "a.1.0".
		</p>
		<p>
			With this format, only the 1 item following the "." (period) is recognized as an element.
			If you want to use an expression for the element, you need to enclose it in parentheses like <code>a.(a+5)=10</code>.
		</p>
		<p>
			When using arrays for string type variables, use the sdim command.
			With the sdim command, first specify the initial number of characters for the string to be handled, and then specify the number of elements. For example:
		</p>
		<pre>; Example
    sdim a,32,5  ; Variable a can handle strings up to 32 characters long with 5 elements
    a(0)="test"
    a(1)="message"</pre>
		<p>
			Specify two parameters after the variable name, as shown above.
			Also, the sdim command can be used to secure the initial number of characters for a string.
		</p>
		<pre>; Example
    sdim a,200    ; Variable a can handle strings up to 200 characters long</pre>
		<p>
			This is not an array variable, but a regular variable.
			If the data assigned to a string type variable exceeds the initial number of characters, it will be automatically reallocated, so in most cases, there is no need to worry about the initial number of characters.
		</p>
		<p>
			By adding a "," to the parameters to be assigned, you can also continuously assign values to an array variable.
		</p>
		<pre>; Example
	tmp=1,5,10	; Continuously assign to an array</pre>
		<p>
			In the above example, it is the same as <code>tmp(0)=1:tmp(1)=5:tmp(2)=10</code>.
			To start assigning from the middle of the array, use:
		</p>
		<pre>; Example
	tmp(2)=10,20,50	; Continuously assign from element 2</pre>
		<p>
			In this example, it is the same as <code>tmp(2)=10:tmp(3)=20:tmp(4)=50</code>.
			You can also continuously assign strings like <code>tmp="ABC","DEF","GHI"</code>.
		</p>

		<h3 id="FUNC">Functions</h3>
		<p>
			Functions are used within parameter expressions to obtain values transformed from a given value.
			By specifying parameters within parentheses following the name indicating the function, a result is returned.
		</p>
		<pre>; Example
	x=sin(3.141592)</pre>
		<p>
			In the above example, the sine value of 3.141592 is obtained and assigned to the variable x.
			Functions include various types, from arithmetic functions such as trigonometric functions to functions that handle strings.
			Functions must always be used within an expression. They cannot be used as commands (statements).
		</p>
		<p>
			HSP3 has the following functions available as standard.
		</p>
		<table class="keywordlist" summary="Introduces a list of functions that are available as standard.">
			<caption>List of functions available as standard</caption>
			<tr><th>Function Name</th><th>Return Value</th><th>Content</th></tr>
			<tr><td>int</td><td>Integer</td><td>Converts the parameter to an integer</td></tr>
			<tr><td>rnd</td><td>Integer</td><td>Generates a random number from 0 to (parameter-1)</td></tr>
			<tr><td>strlen</td><td>Integer</td><td>Returns the length of the string</td></tr>
			<tr><td>length</td><td>Integer</td><td>Returns the number of array elements the variable has (1-dimensional)</td></tr>
			<tr><td>length2</td><td>Integer</td><td>Returns the number of array elements the variable has (2-dimensional)</td></tr>
			<tr><td>length3</td><td>Integer</td><td>Returns the number of array elements the variable has (3-dimensional)</td></tr>
			<tr><td>length4</td><td>Integer</td><td>Returns the number of array elements the variable has (4-dimensional)</td></tr>
			<tr><td>vartype</td><td>Integer</td><td>Returns the type of the variable</td></tr>
			<tr><td>varptr</td><td>Integer</td><td>Returns the address indicating the data of the variable</td></tr>
			<tr><td>varuse</td><td>Integer</td><td>Returns the usage status of the variable</td></tr>
			<tr><td>gettime</td><td>Integer</td><td>Returns the date and time</td></tr>
			<tr><td>str</td><td>String</td><td>Converts the parameter to a string</td></tr>
			<tr><td>dirinfo</td><td>String</td><td>Returns specific directory information</td></tr>
			<tr><td>peek</td><td>Integer</td><td>Extracts a value from the buffer</td></tr>
			<tr><td>wpeek</td><td>Integer</td><td>Extracts a value from the buffer</td></tr>
			<tr><td>lpeek</td><td>Integer</td><td>Extracts a value from the buffer</td></tr>
			<tr><td>double</td><td>Real number</td><td>Converts the parameter to a real number</td></tr>
			<tr><td>sin</td><td>Real number</td><td>Returns the sine value (parameter unit is radians)</td></tr>
			<tr><td>cos</td><td>Real number</td><td>Returns the cosine value (parameter unit is radians)</td></tr>
			<tr><td>tan</td><td>Real number</td><td>Returns the tangent value (parameter unit is radians)</td></tr>
			<tr><td>atan</td><td>Real number</td><td>Returns the arctangent value</td></tr>
			<tr><td>sqrt</td><td>Real number</td><td>Returns the root (square root) value</td></tr>
			<tr><td>logf</td><td>Real number</td><td>Returns the logarithmic value</td></tr>
			<tr><td>expf</td><td>Real number</td><td>Returns the exponential value</td></tr>
			<tr><td>abs</td><td>Integer</td><td>Returns the absolute value of an integer</td></tr>
			<tr><td>absf</td><td>Real number</td><td>Returns the absolute value of a real number</td></tr>
			<tr><td>limit</td><td>Integer</td><td>Constrains an integer value within a range</td></tr>
			<tr><td>limitf</td><td>Real number</td><td>Constrains a real number value within a range</td></tr>
			<tr><td>sysinfo</td><td>Integer</td><td>Gets system information</td></tr>
			<tr><td>ginfo</td><td>Integer</td><td>Gets information about the window</td></tr>
			<tr><td>objinfo</td><td>Integer</td><td>Gets information about the window object</td></tr>
		</table>

		<h3 id="LABEL">Labels</h3>
		<p>
			You can give a name as a label to indicate a position on the program.
			The label is indicated by a string of 59 characters (single-byte) or less following *(asterisk).
		</p>
		<pre>; Example

*label
    mes "Wait.":wait 100
    goto *label            ; Generates an infinite loop</pre>
		<p>
			Labels are mainly used to specify the jump destination of the goto command, the gosub command, or the button command.
			Label names cannot be duplicated within a single source script.
			Also, they cannot be duplicated with variable names.
		</p>
		<p>
			The HSP script editor has a <a href="#LABELLIST">"Label List"</a> feature that allows you to list the labels in the script, so please use it as appropriate.
		</p>
		<p>
			It is also possible to assign the position of the label to a variable.
		</p>
		<pre>; Example
	a=*test</pre>
		<p>
			In this case, the position "*test" is assigned to the variable a.
			After that, the variable a is treated as a label type variable, and it becomes possible to specify a label type variable in the place where a label is specified for a parameter.
		</p>
		<p>
			The following is an example of a sample script using the label type.
		</p>
		<pre>; Label type variable test
;
    ldim a,2
    mes "TYPE="+vartype(a)
    mes "USE(0)="+varuse(a(0))
    a(0)=*test
    a(1)=*test2
    mes "USE(0)="+varuse(a(0))
    gosub a(0)
    gosub a(1)
    mes "OK"
    stop
*test
    mes "JUMP OK"
    return
*test2
    mes "JUMP OK2"
    return
</pre>
		<p>
			For label type variables, the type value "1" is acquired by the vartype function.
			Also, it is possible to determine whether a valid label is assigned by the varuse function.
			The array of label type variables can be secured by specifying <code>ldim a,20</code>.
		</p>
		<p>
			Label type variables can make it difficult to see where the script is jumping to, making it difficult to grasp the overall picture.
			On the other hand, they can efficiently manage a large number of jump destinations that cannot be processed by on~goto, etc.
		</p>
		<p>
			HSP supports the local label function.
			This is a function that allows you to use labels with special names as many times as you like, which is convenient when there is nothing in particular or when it is troublesome to give a name.
		</p>
		<pre>; Example
    mes "GO!"
*@
    mes "A="+a
    a+
    if a&lt;5 : goto *@back    ; Return to the previous local label
    stop</pre>
		<p>
			Local labels are defined with the name "*@". Unlike other
			labels, this can be placed as many times as you like in one source script.
		</p>
		<p>
			When referring to this local label with a goto command, etc., use
			"*@back" and "*@forward".
			"*@back" refers to the closest local label that is above that location.
			"*@forward" refers to the closest local label that is below that location.
		</p>
		<p>
			"*@back" can be abbreviated as "*@b".
			"*@forward" can be abbreviated as "*@f".
		</p>
		<p>
			If local labels are used too much, the script may become difficult to read.
			Please use them after considering the readability later.
		</p>


		<h3 id="IF">Conditional Judgment</h3>
		<p>
			To perform conditional judgment, use the if command. If the condition specified by the parameter of the if command is satisfied, the subsequent command is executed; otherwise, execution continues from the next line.
		</p>
		<pre>; Example
    a=10
    if a=10 : mes "a is 10."</pre>
		<p>
			In the above example, the "a=10" part is the conditional expression. Conditional expressions mainly use:
		</p>
		<table class="keywordlist" summary="Introduces a list of conditional expressions that can be used in HSP.">
			<caption>List of conditional expressions that can be used in HSP</caption>
			<tr><th>Conditional Expression</th><th>Meaning</th></tr>
			<tr><td>a=b</td><td>a and b are equal</td></tr>
			<tr><td>a!b</td><td>a and b are not equal</td></tr>
			<tr><td>a&lt;b</td><td>a is less than b</td></tr>
			<tr><td>a&gt;b</td><td>a is greater than b</td></tr>
			<tr><td>a&lt;=b</td><td>a is less than or equal to b</td></tr>
			<tr><td>a&gt;=b</td><td>a is greater than or equal to b</td></tr>
		</table>

		<p>
			After if + conditional expression, separate with: (colon), and then write the part to be executed if the condition is satisfied.
			(Similarly to C language and Java, you can write "= " and "! " as "==" and "!=".)
		</p>
		<p>
			To make complex conditional judgments, you can also use logical expressions.
		</p>
		<table class="keywordlist" summary="Introduces a list of logical expressions that can be used in HSP.">
			<caption>List of logical expressions that can be used in HSP</caption>
			<tr><th>Conditional Expression</th><th>Meaning</th></tr>
			<tr><td>a&amp;b</td><td>Both a and b are true (and)</td></tr>
			<tr><td>a|b</td><td>Either a or b is true (or)</td></tr>
		</table>
		<p>
			This allows you to describe multiple conditions at once.
		</p>
		<pre>; Example
    a=10:b=20
    if a=10|b=10 : mes "Either a or b is 10."</pre>

		<p>
		In the example above, the conditional expressions "a=10" and "b=10" are connected with | (or) so that a correct result is output if either is correct.
Logical operations can be written not only with symbols like "|" and "&amp;" but also with the strings "or" and "and".
		</p>
		<pre>; Example
            if (a=10)or(b=10) : mes "Either a or b is 10."</pre>
		<p>
			The result is the same even if written as above.
		</p>
		<p>
			In HSP, logical operations are treated as bitwise operations, so please note that they are not equivalent to logical operators such as "&amp;&amp;" and "||" used in C, Java, etc.
		</p>
		<p>
			If you want to change the flow of the program depending on the condition,
		</p>
		<pre>; Example
    a=10
    if a&gt;10 : goto *over10
    mes "a is 10 or less."
    stop
*over10
    mes "a is greater than 10."
    stop</pre>
		<p>
			As shown above, it is also possible to jump to another label with the goto command.
			It is also possible to write a process for when the condition is not met using the else command.
		</p>
		<pre>; Example
    a=10
    mes "a is,"
    if a=10 : mes "10." : else : mes "not 10."
    stop</pre>
		<p>
			In this case, the part up to the else command is executed if the condition is met, and the part after the else command is executed if the condition is not met.
			The following lines will be executed as usual regardless of the condition.
		</p>
		<p>
			Conditional judgments can also be executed over multiple lines.
			If you want to describe the script to be executed when the condition of the if command is true over multiple lines,
		</p>
		<pre>; Example
    a=10
    if a&gt;5 {
        mes "TRUE"
        mes "(MULTILINE IF)"
    }
    stop</pre>
		<p>
			Specify the part from the beginning with "{" to the end with "}".
			(In the above example, TAB is added at the beginning of the line in C language style to make it easier to see, but it is not particularly necessary. Please describe it so that it is easy for the user to see.)
		</p>
		<p>
			You can also specify multiple lines for the else command.
		</p>
<pre>; Example
    a=10
    if a&gt;5 {
        mes "TRUE"
        mes "(MULTILINE IF)"
    } else {
        mes "  FALSE"
        mes "  (MULTILINE IF)"
    }
    return</pre>
		<p>
			However, please note that multiple lines will not be specified unless you write "{" after else.
		</p>
		<pre>; Example
    if a&gt;5 {
        mes "TRUE"
    }
    else                    ; &lt;- Wrong
    {
        mes "false"
    }</pre>
		<p>
			The above example is incorrect. It will be an error.
			The else command, like the if command, is only valid for that one line unless there is a "{".
		</p>
		<p>
			It is also possible to execute the if command in multiple layers.
		</p>
		<pre>; Example
    a=10
    b=10
    c=10
    if a&gt;5 {
        if b&gt;5 {
            if c&gt;5 { mes "--3" } else { mes "--2" }
        } else {
            mes "--1"
        }
    }</pre>
		<p>
			In the above example, "--1" is displayed if variable a is greater than 5, "--2" is displayed if variables a and b are greater than 5, and "--3" is displayed if variables a, b, and c are greater than 5.
			Multiple layering of if commands can make the script gradually more complex, so please use it with caution.
			In HSP, up to 128 layers of nesting are possible.
		</p>


		<h3 id="REPEAT">Repeat Command</h3>
		<p>
			The repeat~loop command is an essential command for performing repetitive operations in HSP.
		</p>
		<pre>; Example
    repeat 5
    mes "Repeat["+cnt+"]"
    loop</pre>
		<p>
			As shown above, if you specify the number of times after the repeat command, the command up to the loop command will be repeated that many times.
			During the repetition, the system variable cnt is automatically counted up as 0, 1, 2, 3...
		</p>
		<p>
			If 0 is specified for the number of repetitions, the repeat~loop range is skipped.
			Also, if the number of repetitions is omitted or a negative value is specified, it will be an infinite loop.
			By combining the repeat~loop command with the break and continue commands, more advanced processing becomes possible.
		</p>
		<p>
			The break command forcibly exits the repeat~loop command repetition in the middle.
		</p>
		<pre>; Example
    repeat 5
    if cnt=2 : break
    mes "Repeat["+cnt+"]"
    loop
    stop</pre>
		<p>
			In the above example, the break command is executed based on the if command judgment when the system variable reaches 2, that is, in the 3rd loop.
			When the break command is executed, the repetition is forcibly exited even if the number of repetitions is still remaining,
			Execution continues from the command after the loop command.
			The commands after the break command (mes command in the above example) are not executed.
		</p>
		<p>
			Using this command, it is possible to create scripts such as the following.
		</p>
		<pre>; Example
    repeat
        getkey a,1
        if a&gt;0 : break
        await 10
    loop
    stop</pre>
		<p>
			The script above is a loop that waits until the left mouse button is pressed.
			If the number of repetitions for the repeat command is omitted or a negative value is specified, it will be an infinite loop.
			By using this, the same part is repeated until the button state becomes 1.
		</p>
		<p>
			When the button is pressed, the break command is executed and the repetition is exited.
			Until now, such scripts had to describe the repetitive structure using the goto command,
			By using the repeat~loop and break commands, a conditional infinite loop can be easily realized without preparing a label.
		</p>
		<p>
			The continue command, on the other hand, is a command to redo the repetition.
		</p>
		<pre>; Example
    repeat 5
        if cnt=2 : continue
        mes "cnt="+cnt
    loop
    stop</pre>
		<p>
			In the above example, the continue command is executed when the system variable cnt reaches 2.
			When the continue command is executed, it returns to the repeat command and executes the next repetition.
		</p>
		<p>
			When the above script is executed,
		</p>
		<pre>; Display example
    cnt=0
    cnt=1
    cnt=3
    cnt=4</pre>
		<p>
			You can see that the mes command is not executed only when the system variable cnt is 2.
			It may be difficult to understand at first, but the continue command can also be said to have the same function as the loop command, although it is not the location of the loop command.
			The repetition counter is incremented by 1 as with the loop command even when the continue command is executed.
			If the continue command is executed in the last repetition, the repeat~loop ends, that is, execution continues from the command after the loop command.
		</p>
		<p>
			Furthermore, there is another way to use the continue command by specifying a parameter.
			By specifying a numerical value or a numerical variable after continue, you can change the content of the system variable cnt, which indicates the repetition counter.
		</p>
		<p>
			For example, if you specify "continue 1", the content of the system variable cnt becomes 1,
			The repetition continues from the next of the repeat command with that value.
			If the parameter is omitted and only "continue" is specified, the same processing as the loop command is performed,
			If a numerical value is specified, the counter value is changed and the repetition is redone.
			Therefore,
		</p>
		<pre>; Example
    repeat 1
        await 10
        getkey a,1
        if a=0 : continue 0
    loop
    stop</pre>
		<p>
			In such a script, the repeat~loop, which should normally only be executed once,
			Although it is a repetition, if the left mouse button is not pressed, the counter is reset to 0
			It becomes an infinite loop. This waits until the button is pressed.
		</p>
		<p>
			Both the break command and the continue command must be used within the repeat~loop command. Also, any number of them can be used within the repeat~loop command.
		</p>
		<p>
			What you have to be careful about is that the repeat~loop commands must be connected in order as the program flow. If there is a repeat command, there must be a loop command on the line below it.
			The compiler will output an error if only the repeat command is executed in a subroutine jumped to by gosub,
			Or if the repeat~loop command order is disrupted by jumping to another location on the script with the goto command and executing the loop command.
		</p>
		<p>
			The repeat~loop command can be used multiple times.
		</p>
		<pre>; Example
    repeat 5
        if cnt=2 : continue
        repeat 2
            mes "Inner loop cnt="+cnt
        loop
        mes "Outer loop cnt="+cnt
    loop
    stop</pre>
		<p>
			In the above example, TAB is added to make it easier to understand, but there is a repeat~loop command that repeats 2 times in the structure that repeats 5 times.
			Even when repetitions are nested, the break and continue commands function for the corresponding loop.
			This is the same as the system variable cnt showing the value for the corresponding loop.
		</p>
		<p>
			If the program control moves to another location using the goto command or the like from within the repeat~loop command,
			The next time the repeat command is executed, it will be a multiple repetition.
			Be sure to either normally end the loop with the repeat~loop command or exit with the break command.
			If you exit with the goto command, it will be a multiple loop and an error will occur.
			The repeat~loop command can normally repeat up to 32 times in multiple layers.
		</p>


		<h3 id="MEM_NOTEPAD">Memory Notepad Command</h3>
		<p>
			The memory notepad command set is a unique and convenient feature that allows you to handle strings on a line-by-line basis. This makes it easy to load, parse, and process text files.
			Also, the commands for displaying combo boxes and list boxes (combox, listbox commands), strings used to specify parameters, and strings returned by the dirlist command for examining the contents of directories can be processed simply by using memory notepad commands.
		</p>
		<p>
			Simply put, the memory notepad command is a command set for handling strings containing multiple lines in the same way as using a text editor like Windows "Notepad".
			A normal string is a collection of arbitrary characters, such as "ABCDEFG".
			A string containing multiple lines is a string with a slightly complex structure, such as "ABCD\nEFGH", with a line break (\n) in between, where the first line is "ABCD" and the second line is "EFGH".
			Text files that can be loaded and saved with a text editor can also be said to be strings containing multiple lines.
			The memory notepad command allows you to extract or modify these strings on a line-by-line basis.
		</p>
		<table summary="Introduces Memory Notepad instructions in a list format." class="keywordlist">
			<caption>Memory Notepad Instruction List</caption>
			<tr><th>Instruction</th><th>Main Function</th><th>Remarks</th></tr>
			<tr><td>notesel</td><td>Specifies the variable to be treated as a memory notepad</td><td></td></tr>
			<tr><td>noteadd</td><td>Adds content to the specified line</td><td>Insertion/Overwrite mode available</td></tr>
			<tr><td>noteget</td><td>Reads the content of the specified line</td><td></td></tr>
			<tr><td>notedel</td><td>Deletes the specified line</td><td></td></tr>
			<tr><td>noteload</td><td>Loads content from a file</td><td></td></tr>
			<tr><td>notesave</td><td>Writes content to a file</td><td></td></tr>
			<tr><td>noteunsel</td><td>Restores the previously selected variable</td><td></td></tr>
			<tr><td>noteinfo</td><td>Retrieves information about the memory notepad</td><td></td></tr>
			<tr><td>notemax</td><td>Gets the total number of lines</td><td>Used as a macro</td></tr>
			<tr><td>notesize</td><td>Gets the total size (in bytes)</td><td>Used as a macro</td></tr>
			<tr><td>notefind</td><td>Searches for a line containing a specific string</td><td>Used as a function</td></tr>
		</table>
		<p>
			The basic usage is to first specify a string type variable with the notesel instruction.
			After that, all memory notepad instructions will target the variable specified there.
		</p>
		<p>
			The specified variable must be of string type.
			After specifying a variable with the notesel instruction, you can freely use the noteinfo, noteadd, noteget, and notedel instructions to
			access the content (string) of the variable.
		</p>
		<pre>; Example
    a="ONION\nTOMATO\nCARROT"
    notesel a
    noteget b,0
    mes "index0="+b
    noteget b,1
    mes "index1="+b
    noteget b,2
    mes "index2="+b
    stop</pre>
		<p>
			In the example above, the variable a is assigned three lines: "ONION", "TOMATO", and "CARROT".
			First, the variable a is specified with the notesel instruction, and then the content of each line is retrieved and displayed using the noteget instruction.
		</p>
		<p>
			Memory Notepad instructions use a unit called "index" to specify lines.
			The first line is index 0, the next is index 1, and so on.
			The line number would start at the first line, but note that the index starts at 0.
			In other words, "noteget b,0" means reading the first line into the variable b.
		</p>
		<pre>; Example
    a="ONION\nTOMATO\nCARROT"
    notesel a
    noteadd "POTATO"
    mes a
    stop</pre>
		<p>
			In the example above, the line "POTATO" is added to the three elements "ONION", "TOMATO", and "CARROT" assigned to the variable a.
			You can check the result by displaying it with "mes a" on the 4th line.

			To add content, use the noteadd instruction. "noteadd "POTATO"" adds "POTATO" to the last line.
		</p>
		<pre>noteadd "POTATO",1</pre>
		<p>
			If you specify the above, it will be added at index 1.
			The content that was at index 1 and later will be shifted down. Also,
		</p>
		<pre>noteadd "POTATO",1,0</pre>
		<p>
			will also add to index 1, but it will be added overwriting the same line.
			The content that was at index 1 will be deleted and replaced with the specified content.
			An instruction is also available to delete the line at the specified index.
		</p>
		<pre>notedel 1</pre>
		<p>
			deletes index 1.
			These memory notepad instructions are powerful when combined with other instructions.
			Memory Notepad instructions can be used for processing text files, multi-line text entered with the mesbox instruction,
			the result of the dirlist instruction, and the parameters specified with the combox and listbox instructions.
			In addition, the string extracted in units of lines can be handled in units of characters with the poke, peek instructions, and so on.
		</p>
		<pre>; Example
    notesel a
    noteload "aaa.txt"
    idx=0
    repeat notemax
        noteget b,idx
        mes "index"+idx+"="+b
        idx++
    loop
    stop</pre>
		<p>
			In the example above, a text file named "aaa.txt" is loaded and all its lines are displayed with their index numbers.
			By using the noteload instruction, the size of the memory buffer secured for the variable is
			adjusted to match the loaded file.
			If you do not know the total number of lines, use the noteinfo function or notemax.
			notemax is a macro that is assigned the number of lines of text that is the target of the memory notepad and can be used in the same way as system variables.
		</p>
		<pre>; Example
    sdim list,32000
    sdim tmem,32000
    tmem=""
    fid=""
    ;
    notesel list
    dirlist list,"*.*"
    sel=0
    objsize 160,24
    listbox sel,150,list    ; ID=0
    button "SELECT",*ok    ; ID=1
    pos 180,0
    mesbox tmem,450,200    ; ID=2
    stop
*ok
    noteget fname,sel
    exist fname
    if (strsize&lt;=0)or(32000&lt;strsize) : goto *lderr
    bload fname,tmem
    objprm 2,tmem
    stop
*lderr
    dialog "LOAD ERROR!"
    stop</pre>
		<p>
			This is a sample that combines memory notepad instructions with other instructions.
			It displays a list of files in the current directory in a list box, and then displays the contents of the file selected there in the message box on the right.
		</p>
		<p>
			The strings used in the dirlist and listbox instructions are both multi-line texts that can be handled by memory notepad instructions.
			It may seem complicated at first, but it allows you to handle a lot of data at once, and
			the range of applications can be further expanded depending on how you use it.
		</p>

		<h3 id="SORT">Sort Instructions</h3>
		<p>
			The sort instruction set is a group of instructions for sorting numerical values and strings.
			It makes it easy to efficiently process multiple data and strings.
		</p>
		</p>
		<table summary="Introduces the sort instruction set in a list format." class="keywordlist">
			<caption>Sort Instruction Set List</caption>
			<tr><th>Instruction</th><th>Main Function</th><th>Remarks</th></tr>
			<tr><td>sortval</td><td>Sorts an array variable numerically</td><td></td></tr>
			<tr><td>sortstr</td><td>Sorts an array variable alphabetically</td><td></td></tr>
			<tr><td>sortnote</td><td>Sorts a memory notepad string</td><td></td></tr>
			<tr><td>sortget</td><td>Gets the index of the sort source</td><td>Gets it after sorting</td></tr>
		</table>
		<p>
			Numerical sorting is performed on integer or real number values assigned to array variables.
		</p>
		<pre>
		dim n,10
		sortval n,0
		</pre>
		<p>
			In the example above, the range n(0) to n(9) of the one-dimensional array that variable n has is rearranged in ascending numerical order.
			When the instruction is executed, the contents of the array variable are all rearranged.
			The sorting order can be specified with the second parameter. If it is 0, it sorts in ascending numerical order, and if it is 1, it sorts in descending order.
		</p>
		<pre>
		sdim n,64,10
		sortstr n,0
		</pre>
		<p>
			In the example above, the range n(0) to n(9) of the one-dimensional array that the string type variable n has is rearranged in ascending character code order.
			When the instruction is executed, the contents of the array variable are all rearranged.
			The sorting order can be specified with the second parameter. If it is 0, it sorts in ascending character code order, and if it is 1, it sorts in descending character code order.
		</p>
		<p>
			In addition, the sortnote instruction is available for sorting strings with line breaks specified by the memory notepad instruction (notesel), and it can be used differently depending on the application.
			After the sort instruction is executed, you can use the noteget instruction to find out the original position.
			This is to find out the original position (index) of the item in the sort result that was executed immediately before.
		</p>
		<pre>
		sortget a,0
		</pre>
		<p>
			In the example above, the variable a obtains where index 0 (the first item) was originally located.
			(The index value is the same as the array element value)<br>
			For example, if the value of variable a is 5, it indicates that the item entered in index 5 was rearranged to index 0.
		</p>


		<h3 id="SYSVAR">System Variables</h3>
		<p>
			System variables are variables that are automatically
			assigned values when the system starts or when a specific instruction is executed.
			You can refer to them in the same way as normal variables, but
			you cannot assign values to them using an assignment statement (=).
			For some system variables, it is possible to assign values using the return instruction.
		</p>
		<table class="keywordlist" summary="Introduces system variables in a list format.">
			<caption>System Variable List</caption>
			<tr><th>Variable Name</th><th>Content Set</th></tr>
			<tr><td>system</td><td>Undefined</td></tr>
			<tr><td>hspstat</td><td>Gets HSP runtime information (<a href="#SYSVAR_1">*1</a>)</td></tr>
			<tr><td>hspver</td><td>HSP version number (<a href="#SYSVAR_2">*2</a>)</td></tr>
			<tr><td>cnt</td><td>Counter for repeat〜loop loop</td></tr>
			<tr><td>err</td><td>Error code</td></tr>
			<tr><td>stat</td><td>General-purpose system variable to store the status of various instructions</td></tr>
			<tr><td>mousex</td><td>Mouse cursor X coordinate</td></tr>
			<tr><td>mousey</td><td>Mouse cursor Y coordinate</td></tr>
			<tr><td>mousew</td><td>Mouse wheel value</td></tr>
			<tr><td>strsize</td><td>Number of bytes read by the getstr instruction</td></tr>
			<tr><td>refstr</td><td>General-purpose system variable to store strings</td></tr>
			<tr><td>refdval</td><td>General-purpose system variable to store real number values</td></tr>
			<tr><td>looplev</td><td>Nesting level of repeat〜loop</td></tr>
			<tr><td>sublev</td><td>Nesting level of subroutine (module)</td></tr>
			<tr><td>wparam</td><td>Windows system value (wParam) saved at the time of interrupt</td></tr>
			<tr><td>lparam</td><td>Windows system value (lParam) saved at the time of interrupt</td></tr>
			<tr><td>iparam</td><td>Value indicating the cause of the interrupt</td></tr>
			<tr><td>thismod</td><td>Currently valid module variable</td></tr>
			<tr><td>notemax</td><td>Number of lines in the memory notepad</td></tr>
			<tr><td>notesize</td><td>Number of characters in the memory notepad</td></tr>
			<tr><td>hwnd</td><td>Current window handle</td></tr>
			<tr><td>hdc</td><td>Current device context</td></tr>
			<tr><td>hinstance</td><td>Current instance handle</td></tr>
			<tr><td>ginfo_mx</td><td>Mouse cursor X coordinate on the screen</td></tr>
			<tr><td>ginfo_my</td><td>Mouse cursor Y coordinate on the screen</td></tr>
			<tr><td>ginfo_act</td><td>Active window ID</td></tr>
			<tr><td>ginfo_sel</td><td>Operation target window ID</td></tr>
			<tr><td>ginfo_wx1</td><td>Top left X coordinate of the window</td></tr>
			<tr><td>ginfo_wy1</td><td>Top left Y coordinate of the window</td></tr>
			<tr><td>ginfo_wx2</td><td>Bottom right X coordinate of the window</td></tr>
			<tr><td>ginfo_wy2</td><td>Bottom right Y coordinate of the window</td></tr>
			<tr><td>ginfo_vx</td><td>Window scroll X coordinate</td></tr>
			<tr><td>ginfo_vy</td><td>Window scroll Y coordinate</td></tr>
			<tr><td>ginfo_sizex</td><td>X size of the entire window</td></tr>
			<tr><td>ginfo_sizey</td><td>Y size of the entire window</td></tr>
			<tr><td>ginfo_winx</td><td>Client X size of the screen</td></tr>
			<tr><td>ginfo_winy</td><td>Client Y size of the screen</td></tr>
			<tr><td>ginfo_sx</td><td>Initial X size of the screen</td></tr>
			<tr><td>ginfo_sy</td><td>Initial Y size of the screen</td></tr>
			<tr><td>ginfo_mesx</td><td>Message output X size</td></tr>
			<tr><td>ginfo_mesy</td><td>Message output Y size</td></tr>
			<tr><td>ginfo_r</td><td>Currently set color code (R)</td></tr>
			<tr><td>ginfo_g</td><td>Currently set color code (G)</td></tr>
			<tr><td>ginfo_b</td><td>Currently set color code (B)</td></tr>
			<tr><td>ginfo_paluse</td><td>Desktop color mode</td></tr>
			<tr><td>ginfo_dispx</td><td>X size of the entire desktop</td></tr>
			<tr><td>ginfo_dispy</td><td>Y size of the entire desktop</td></tr>
			<tr><td>ginfo_cx</td><td>X coordinate of the current position</td></tr>
			<tr><td>ginfo_cy</td><td>Y coordinate of the current position</td></tr>
			<tr><td>ginfo_intid</td><td>Window ID at the time of message interrupt</td></tr>
			<tr><td>ginfo_newid</td><td>Unused window ID</td></tr>
			<tr><td>dir_cur</td><td>Current directory (folder)</td></tr>
			<tr><td>dir_exe</td><td>Directory (folder) where the executable file is located</td></tr>
			<tr><td>dir_win</td><td>Windows directory (folder)</td></tr>
			<tr><td>dir_sys</td><td>Windows system directory (folder)</td></tr>
			<tr><td>dir_cmdline</td><td>Command line string</td></tr>
			<tr><td>dir_desktop</td><td>Desktop directory (folder)</td></tr>
			<tr><td>dir_mydoc</td><td>My Documents directory (folder)</td></tr>
			<tr><td>dir_tv</td><td>HSPTV directory (folder)</td></tr>
		</table>
		<dl>
			<dt id="SYSVAR_1">*1</dt>
			<dd>
				<p>This is the sum of all the following information:</p>
				<ul>
					<li>Debug mode = 1</li>
					<li>When the screensaver starts = 2</li>
					<li>Console mode = 16</li>
					<li>Macintosh version of HSP = $80</li>
					<li>HSP3Dish = $100</li>
					<li>Linux version of HSP = $1000</li>
					<li>UTF8 string runtime = $20000</li>
					<li>64-bit runtime = $40000</li>
				</ul>

			</dd>
			<dt id="SYSVAR_2">*2</dt>
			<dd>
				<p>
					This is the value of the version code (8bit) + minor version code (8bit).
					For example, 3.5 is $3500.
				</p>
			</dd>
		</dl>

		<h2 id="EX_GRAMMAR">Extended Grammar</h2>


		<h3 id="MODULE">Module</h3>
		<p>
			The module feature is a mechanism for organizing and reusing scripts.
			The module feature should be useful for intermediate and advanced users who have learned HSP to some extent.
			Various applications are possible, such as module variables that collectively store variables handled within a module, and local variables.
		</p>
		<p>
			Even if you don't use the module feature, you can use new commands added by others using the module feature. This is no different from the DLL extension plugin mechanism.
		</p>
		<p>
			For example, let's say you have a source script called "test1.as".
			Assume that this source script uses variables a and b.
			If another person creates a source script called "test2.as" and there is a very useful subroutine in it, what will happen?
			If "test2.as" does not use the names of variables a and b, there is no problem, and you may be able to bring just the subroutine as is.
			However, it would be very troublesome if "test2.as" also used variables a and b for different purposes.
		</p>
		<p>
			Using the HSP module feature, it is possible to call the script "test2.as" from "test1.as", but the variables used in "test1.as" and "test2.as" are treated as independent (even if the names are the same).
			Also, subroutines in this independent script can be registered as new commands, and parameters can be passed and received.
		</p>
		<p>
			It becomes possible to reuse modules you have created in the past, publish them for others to use, or use modules created by someone else, allowing you to apply HSP scripts more widely.
		</p>
		<p>
			To master HSP modules, you need to learn about module specification commands, user extension commands, etc.
			These are commands that provide convenient functions even by themselves.
			Don't try to memorize them all at once, but master them one by one, starting with what you understand.
		</p>
		<p>
			User-defined commands are one of the commands added along with the HSP module feature, and allow users to arbitrarily add commands with new names.
			This will be very powerful even if used independently of the HSP module feature.
		</p>

		<h3 id="USERDEF_COMMAND">User-Defined Commands</h3>
		<p>User-defined commands are used as follows:</p>
		<pre>; Example
    goto *main

#deffunc routine
    mes "sub-routine"
    return

*main
    routine
    stop</pre>
		<p>
			Since there is no "routine" command in HSP, it would normally result in an error, but when you actually execute this script, "sub-routine" is displayed and the "routine" command is executed.
			User-defined commands can be defined by the "#deffunc" command.
		</p>
		<pre>#deffunc command name</pre>
		<p>
			adds a command with a new name.
			From then on, when a new command appears, the program jumps to the subroutine where "#deffunc" is located.
		</p>
		<p>In other words,</p>
		<pre>; Example
    goto *main

*routine
    mes "sub-routine"
    return

*main
    gosub *routine</pre>
		<p>Even with a script like this,</p>
<pre>; Example
    goto *main
    
#deffunc routine
    mes "sub-routine"
    return
    
*main
    routine</pre>
		<p>
		"#deffunc" can be placed before or after the location where the command is actually used.
		User-defined commands also make it possible to pass parameters to subroutines.
		</p>
<pre>; Example
    goto *main

#deffunc routine int prm1, int prm2
    mes "Parameter 1 is, "+prm1+"."
    mes "Parameter 2 is, "+prm2+"."
    return

*main
    routine 10, 20</pre>
		<p>
			With the old gosub command, when passing values to a subroutine, it was only possible to put the values into predetermined variables and then call the subroutine.
			User-defined commands make it possible to pass values in a smarter way instead.
		</p>
		<p>
			Also, the parameters to pass are not limited to numerical values, but there are many variations such as strings, variables (arrays), etc.
			In the #deffunc command,
		</p>
		<pre>#deffunc new command name parameter type 1 alias name 1,…</pre>
		<p>
			The parameter information is specified in this format.
			You can choose the parameter type from the following:
		</p>
		<table class="keywordlist" summary="List of parameter types">
			<caption>Parameter Type List</caption>
			<tr><th>Type</th><th>Content</th></tr>
			<tr><td>int</td><td>Integer value</td></tr>
			<tr><td>var</td><td>Variable (no array)</td></tr>
			<tr><td>array</td><td>Variable (with array)</td></tr>
			<tr><td>str</td><td>String</td></tr>
			<tr><td>double</td><td>Real value</td></tr>
			<tr><td>label</td><td>Label</td></tr>
			<tr><td>local</td><td>Local variable</td></tr>
		</table>
		<p>
			The alias name indicates the content of the passed parameter and can be used in almost the same way as a variable.
			However, you need to be careful about how you use var and array.
		</p>
		<pre>; Example
#deffunc routine1 var prm
    mes "The content of the variable is, "+prm
    return

#deffunc routine2 array prm
    mes "The content of the variable is, "+prm
    return</pre>
		<p>
			In the above example, if you call "routine1 a(1)", the specification "a(1)" is passed as a parameter as is.
			On the other hand, in the case of "routine2 a(1)", only "a" is passed as a parameter. Therefore, in routine2, the content of a(0) will be displayed.
			Also, as an alias, "prm.1" cannot be specified for routine1 (it will be an error), whereas routine2 can specify "prm.1".
			Please remember that there are two types of variable parameter passing in this way.
		</p>
		<p>
			The parameter type "local" is a slightly special specification. Strictly speaking, this is not a parameter, but a specification of the behavior of the new command.
		</p>
		<pre>; Example
#deffunc routine1 int prm,local a
    mes "Local variable="+a
    a=prm
    return</pre>
		<p>
			As shown above, it is recommended to specify local by adding it at the end of the parameter description. The name specified after local is initialized as a local variable when the new command is executed. Normally, HSP variables are global and always hold some value, but in the case of local variables, they are created when this command is executed and discarded when the command ends.
			Local variables are effective when you want to keep the values of variables independently, such as when performing command recursion (calling itself). In addition, it is also useful for organizing programs such as localizing variable names, but please note that overuse of local variables has overhead for initialization in situations where execution efficiency and speed are required.
		</p>
		<p>
			As a special application, you can register it as a cleanup command by describing "onexit" instead of the parameter type.
			The cleanup command is automatically called at the end of HSP script execution.
		</p>
		<pre>; Example
#deffunc name onexit</pre>
		<p>
			It can be used to clean up after functions have been extended by modules, such as releasing the system or memory.
		</p>


		<h3 id="USERDEF_FUNC">User-Defined Functions</h3>
		<p>
			User-defined functions create new functions in the same way as user-defined commands.
		</p>
		<pre>#defcfunc new function name parameter type 1 alias name 1,…</pre>
		<p>
			can be defined in the same format as user-defined commands.
			With #defcfunc, the behavior of functions evaluated in expressions can be described in a script.
		</p>
		<pre>; Example
#defcfunc half int a
    return a/2</pre>
		<p>
			In the above example, a function named half is registered.
			half is created as a function that returns half the value of the parameter.
			For example, by using it like "half(4)" in an expression, it is processed into the value "2".
			The value returned by the function is specified by the parameter of the return command.
			The value and type specified by the return value are reflected in the expression as is.
		</p>
		<h3 id="DIFF_FUNC_COMMAND">Differences between Functions and Commands</h3>
		<p>
			Two function calling methods, functions and commands, are provided as standard.
			You can choose either of these as needed, but we recommend that you operate according to the following rules.
		</p>
		<ul>
			<li>Command = Provides a function that operates based on parameters</li>
			<li>Function = Processes parameters according to a certain rule and returns a value</li>
		</ul>
		<p>
			Many of the functions provided by the system are provided as commands, and function support is limited to a range that does not cause unnecessary confusion, such as arithmetic functions.
			Especially for scripts released to beginners, using functions too much may make them difficult to understand.
		</p>
		<h3 id="MODULEDEF_COMMAND">Module Definition Commands</h3>
		<p>
			A module refers to a unit of source code that can handle variable names and label names independently.
		</p>
		<pre>; Example
#module
#deffunc test1
    a=a+1
    mes "test1 was called "+a+" times."
    return
#global</pre>
		<p>
			Please remember that modules always start with "#module" and end with "#global".
			In this example, each time the new command test1 is called, the number stored in the variable a
			is incremented.
			As an example of how to call this, let's create the following script.
		</p>
		<pre>; Example
    a=5
    repeat a
        test1
    loop
    mes "Content of a="+a
    stop</pre>
		<p>
			Considering it as a normal subroutine call, the variable name a is also
			used inside test1, so it should not work correctly.
			However, since the source is separated using the module definition command,
			the variable a inside the module and the variable a outside are treated as separate entities,
			so the above script works correctly.
		</p>
		<p>
			Thus, the basic concept of modules is that the section delimited by "#module" to "#global" and
			the other sections are treated as completely separate spaces, and even if variable or label names are duplicated,
			each script will work without any problems. By completely separating subroutines with independent functions
			using user-defined commands, you can promote script reuse and
			encapsulation.
		</p>
		<p>
			Also, you can add a name when defining a module.
		</p>
		<pre>; Example
#module mo
#deffunc test1
    a=a+1
    mes "test1 was called "+a+" times."
    return
#global</pre>
		<p>
			In the example above, a module named "mo" is defined.
			Even if you omit the name and only use "#module", a module name "_m numerical value" will be automatically assigned by the system
			so that it does not overlap with others.
			When multiple modules are defined, they are identified by this module name.
		</p>
		<p>
			If you want to refer to a variable inside a module from outside the module,
			you can use the format "variable name@module name". Conversely,
			to refer to a variable outside (in the #global section) from inside the module,
			you can use the format "variable name@".
			However, this format creates dependencies between the inside and outside of the module,
			so it is not a complete separation of the source and is not recommended.
		</p>

		<h4>Definition of module variables</h4>
		<!-- Slightly added/supplemented 08/01/26 eller -->
		<p>
			Module variables provide a data storage method that allows you to manage multiple variables and data collectively.
			By hiding multiple variables within a module,
			it is a useful function that allows you to simply organize large amounts of data.
		</p>
		<p>
			Variables used inside a module are called module variables, and since they are stored in module
			units, you can create variables with the module type.
			You need to make the following definitions as preparation for creating module variables.
		</p>
		<pre>#module a x,y,z</pre>
		<p>
			In the example above, the module a has three variables: x, y, and z.
			The #module command is a command for defining a space with the name "a" as it has been in the past,
			but in 3.0, it is now possible to define a variable corresponding to the name "a".
			In the sense that module "a" uses the variables x, y, and z,
			these x, y, and z are called module variables.
		</p>
		<p>
			To use module variables, you need to create a variable with the module type.
		</p>
		<pre>    newmod v,a</pre>
		<p>
			In the example above, the variable v for module "a" is initialized.
			With this, the variable v will contain the entire contents of the module variables x, y, and z that module "a" has.
			Variables are initially initialized with the integer value 0. However, for each module, it is also possible to
			prepare commands for initialization.
		</p>
		<pre>#modinit
    x=1:y=2:z=3
    return</pre>
		<p>
			The example above defines a routine (constructor) for initializing module variables.
			Only one initialization routine defined by #modinit can be written per module.
			Modules with #modinit defined will automatically have the
			initialization routine called when the newmod command is used.
			#modinit can specify arguments in the same way as #deffunc.
		</p>
		<pre>#module a x,y,z
#modinit int p1,int p2,int p3
    x=p1:y=p2:z=p3
    return
#global
    newmod v,a,1,2,3</pre>
		<p>
			In the case of the definition above, when the newmod command is executed,
			the parameters described in newmod are passed as is.
		</p>
		<p>
			It may be difficult to understand at first, but the variable v is a container that can hold multiple variables collectively.
			It's the same as storing multiple files in one folder.
		</p>
		<p>
			To access the contents of the stored variables, that is, the module variables,
			it is necessary to define commands specifically for processing within the module.
		</p>
		<pre>#modfunc viewxyz
    mes "x="+x+"/y="+y+"/z="+z
    return</pre>
		<p>
			The example above is a command definition for displaying the module variables x, y, and z.
			Argument specifications, etc. can be done in the same way as #deffunc, but to call this command, you need to
			specify a module-type variable as the first argument of the command.
		</p>
		<p>
			In other words, to call the viewxyz command,
		</p>
		<pre>#module a x,y,z
#modinit int p1,int p2,int p3
    x=p1:y=p2:z=p3
    return
#modfunc viewxyz
    mes "x="+x+"/y="+y+"/z="+z
    return
#global
    newmod v,a,1,2,3    ; You need to initialize the module variables here
    viewxyz v
    stop</pre>
		<p>
			must be written.
			This allows you to display the contents of x, y, and z stored in the module-type variable v in the
			user-defined command viewxyz.
			Apparently, it becomes possible to put three elements x, y, and z into one variable v,
			which is effective in situations where data is handled in sets.
		</p>
		<p>
			In the routine defined by #modfunc, you can use the system variable thismod, which represents its own module variable.
			thismod is used to specify module variables for calling other commands/functions from within a routine that processes module variables.
		</p>
		<p>
			#modfunc is defined as a command, but #modcfunc is also available for defining it as a function.
			Even when defined as a function, a module-type variable must be specified as the first parameter in the same way as a command.
		</p>
		<p>
			Module-type variables can also use arrays.
			In this case, some special usage methods are available.
		</p>
		<p>
			The newmod command from earlier is a command for assigning a new value to a module-type array variable.
			<code>newmod v,a</code>
			is assigned to the array v(0), but if you execute it again, it will be assigned to v(1).
			In other words, the newmod command is a command to automatically secure an empty space in the array of variable v and store the data.
		</p>
		<p>
			Conversely, you can also delete array elements stored with the newmod command.
		</p>
		<pre>    delmod v(0)</pre>
		<p>
			The example above deletes the content corresponding to element 0 of the variable v.
			The deleted element can no longer be used, and will be reused when the newmod command is executed again.
			Also, if necessary, you can define a routine (destructor) that is automatically called when a module variable is discarded by the delmod command.
		</p>
		<pre>#modterm
    mes "BYEBYE"
    return</pre>
		<p>
			The example above displays "BYEBYE" when the module variable is discarded.
			You can check whether the specified element is in use with the varuse function.
		</p>
		<pre>    if varuse(v(0))=0 : mes "v(0) is not in use"</pre>
		<p>
			Also, you can get how far the array element can be used with the length function.
		</p>
		<pre>    mes "Maximum number of array elements="+length(v)</pre>
		<p>
			Furthermore, the foreach command is available for iterating through all usable elements in a module-type variable.
			The foreach command can be used in the same way as the repeat command, but specify the module-type variable name instead of the number of loops.
			After that, the section up to the loop command is repeated for the number of all elements.
		</p>
		<p>
			During the repetition, the system variable cnt changes as the value of the element.
			The system variable cnt skips elements that have been deleted by the delmod command.
		</p>
		<p>
			In other words,
		</p>
		<pre>    foreach v
        viewxyz v(cnt)
    loop</pre>
		<p>
			If you write like this, it means that the viewxyz command is executed for all valid elements in the module-type variable v.
		</p>
		<p>
			When a module-type variable is assigned to another variable, it becomes a clone of the original variable.
			(It does not copy all the contents that were assigned to the original variable)
			In that case, the return value of the varuse function will be "2", indicating that it is a clone.
			A clone of a module-type variable can refer to the contents in the same way as the original variable,
			but you cannot discard the module variable. Also, be careful not to refer to the contents of module variables that have already been discarded.
		</p>
		<p>
			A description of modules is also provided in the separate document <a href="module.htm">Module Feature Guide</a>.
		</p>


		<h3 id="PREPROCESSOR">Preprocessor directives</h3>
		<p>
			Preprocessor directives are instructions that are interpreted and executed at compile time, not at program execution time.
			Preprocessor directives must be written at the beginning of the line, following "#", so that they can be distinguished from other instructions.
		</p>
		<p>
			Preprocessor directives allow you to customize the script description itself. However, overusing them can make the program difficult to understand, so it is recommended for advanced users who have used HSP to some extent.
		</p>
		<p>
			Preprocessor directives usually apply to a single line starting with "#", but a preprocessor line ending with "\" is continued on the next line. This can be used when defining something that does not fit on one line.
		</p>
		<pre>; Example
#define aaa mes "AAA"\
    :mes "BBB"\
    :mes "CCC"

    aaa
    stop</pre>
		<p>
			In the example above, all three lines are interpreted as a #define preprocessor directive. The commands equipped as preprocessor directives are as follows:
		</p>
		<pre>#include "filename"			[Combine external file]</pre>
		<p>
			The file specified by "filename" will also be compiled at the same time.
		
			Even scripts that do not fit in the script editor can be compiled by dividing them into separate files with include.
		</p>
		<pre>#use filename				[Combine external file]</pre>
		<p>
			This is the same as #include, but it allows simplified specification of files prepared in advance in the common folder.
			"#include "hsp3dish.as"" can be written as "#use hsp3dish".
		</p>
		<pre>#define NewName  OriginalName		[Register NewName]</pre>
		<p>
			This is to add a new alias.
			It allows you to use the names of existing HSP commands with different names.
			The NewName must be an English string of up to 20 characters without spaces, and must not overlap with reserved command words or variable names.
		</p>
		<pre>; Example
#define pr print
    pr "message..."
    stop</pre>
		<p>
			As shown above, describe the NewName and the OriginalName separated by a space after #define. Then, the command "pr" will be newly registered and can be used in exactly the same way as the "print" command.
		</p>
		<p>
			The OriginalName does not have to be the name of a command. Numbers and symbols can also be registered as NewName.
		</p>
		<pre>; Example
#define is =
#define plus +
    a is 5 plus 10
    mes "A="+a
    stop</pre>
		<p>
			In the example above, the symbol "=" is defined to be replaced with the word "is", and the symbol "+" is defined to be replaced with the word "plus".
			Then, the line "a is 5 plus 10" will be the same as "a = 5 + 10".
		</p>
		<p>
			It is also possible to expand using parameters.
		</p>
		<pre>; Example
#define reset(%1) %1=10
    reset a
    mes "A="+a
    stop</pre>
		<p>
			In the example above, "reset a" is converted to the script "a=10".
		</p>
		<p>
			In addition, many options such as special expansion parameters are available.
			For more information, please refer to the section "<a href="#DEFINE_MACRO">About #define macro</a>".
		</p>
		<pre>#const MacroName NumericalExpression			[Constant definition of MacroName]</pre>
		<p>
			Sets the replacement string to the specified MacroName.
			This is the same as #define, but #const replaces the result of pre-calculating when replacing constants (numbers).
		</p>
		<pre>; Example
#const KAZU 100+50
    a=KAZU
;    ↓(After expansion)
;    a=150</pre>
		<p>
			This is effective for speeding up the source if the value used in the source
			is already determined. Since it is also possible to include already defined macros,
		</p>
		<pre>; Example
#const ALL 50
#const KAZU 100*ALL
    a=KAZU
;    ↓(After expansion)
;    a=5000</pre>
		<p>
			It can be used as follows.
			For calculation formulas, the same operators and numerical description styles
			as those used in the script can be used only with integers.
		</p>
		<pre>; Example
#const KAZU $5+3*10
    a=KAZU
;    ↓(After expansion)
;    a=35</pre>

		<pre>#undef MacroName					[Cancel MacroName]</pre>
		<p>
			Cancels an already registered MacroName.
			Specifying a MacroName that is not registered does not cause an error and is ignored.
		</p>
		<pre>#if NumericalExpression                      [Compile control from numerical value]
#ifdef MacroName                 [Compile control from macro definition]
#ifndef MacroName                [Compile control from macro definition]
#else                           [Invert compile control]]
#endif                          [End compile control block]</pre>
		<p>
			Specifies ON/OFF of compilation.
			#if ignores the subsequent compilation output and ignores the compilation result if the specified numerical value is 0. If the numerical value is other than 0, the output is ON.
			This compilation control targets the section until #endif appears.
			#endif must exist in pairs with one of #if, #ifdef, or #ifndef.
		</p>
		<pre>; Example
#if 0
    mes "ABC"        ; This part will be ignored
    a=111            ; This part will be ignored
    mes "DEF"        ; This part will be ignored
#endif</pre>
		<p>
			Since it is also possible to use expressions for #if specification,
		</p>
		<pre>; Example
#define VER 5
#if VER&lt;3
    mes "abc"        ; This part will be ignored
    a=111            ; This part will be ignored
    mes "def"        ; This part will be ignored
#endif</pre>
		<p>
			It can also be used as follows. The description of the calculation formula is the same as the #const command.
		</p>
		<p>
			#ifdef turns the output ON if the specified MacroName is defined, and turns the output OFF otherwise.
			The MacroName will be the one defined by #define or #const.
		</p>
		<pre>; Example
#define SW
#ifdef SW
    mes "ABC"        ; This part will be compiled
    a=111            ; This part will be compiled
    mes "DEF"        ; This part will be compiled
#endif</pre>
		<p>
			#ifndef, on the contrary to #ifdef, turns the output OFF if the specified MacroName is defined, and turns the output ON otherwise.
			In addition, by inserting #else in the block, it is possible to describe the operation when the condition is reversed.
		</p>
		<pre>; Example
#ifdef SW
    mes "AAA"        ; When SW is defined
#else
    mes "BBB"        ; When SW is not defined
#endif</pre>
		<p>
			It is also possible to nest #if, #ifdef, #ifndef-#endif procks.
		</p>
		<pre>; Example
#ifdef SW
    #ifdef SW2
        mes "AAA"        ; When SW and SW2 are defined
    #else
        mes "BBB"        ; When SW is defined
    #endif
#endif</pre>

		<pre>#uselib "filename"            Specify external DLL
#func NewName  FunctionName  Type        External DLL call command registration</pre>
		<p>
			You can increase the commands to call programs in external DLLs.
			This allows you to call functions in DLLs created in C language or Delphi from the HSP main program.
		</p>
		<p>
			Since external functions can also be defined as HSP commands by the func command,
			it is possible to freely expand HSP's functions. See the "Extended Plug-in Creation Reference Manual" for details on how to create external DLLs and how to pass parameters with HSP.
		</p>
		<p>
			This command is not necessary when using it normally, so you don't have to memorize it in particular.
		</p>


		<h3 id="DEFINE_MACRO">About #define macro</h3>
		<p>
			#define macros are only for personal customization to make scripts easier to write, and are not for beginners. The functions described here are not frequently used, so please refer to them only when necessary.
		</p>
		<p>
			#define macros basically register replacement strings.
		</p>
		<pre>; Example
#define hyouji mes
    hyouji "AAAAA..."
;    ↓(After expansion)
;    mes "AAAAA..."</pre>
		<p>
			By putting "global" immediately after the #define and #const commands, you can create a macro that can be used permanently in all modules.
		</p>
		<pre>; Example
#module
#define global test 0x1234
#global
    a=test            ; 0x1234 is assigned to a</pre>
		<p>
			Normally, if you define #define in a module, the same name will not be recognized in other modules and global areas.
			By inserting the global designation, you can replace the defined name with a macro in all subsequent locations.
		</p>
		<p>
			In addition to simple replacement macros, expansion with arguments is possible.
			Arguments are specified with argument names %1, %2, %3... enclosed in parentheses after the macro name.
			Arguments must be specified as "%number", and the numbers must be written in order from 1.
			Please note that you cannot specify symbol names like C and C++ preprocessors.
		</p>
		<pre>; Example
#define hyouji(%1) mes "prm="+%1
    hyouji "AAAAA..."
;    ↓(After expansion)
;    mes "prm="+"AAAAA..."</pre>
		<p>
			It is also possible to set initial (default) values for arguments.
		</p>
		<pre>; Example
#define hyouji(%1="PRM=",%2=123) mes %1+%2
    hyouji "AAA",a
    hyouji "BBB"
    hyouji ,b
;    ↓(After expansion)
;    mes "AAA"+a
;    mes "BBB"+123
;    mes "PRM="+b</pre>
		<p>
			Initial (default) values are values that are automatically complemented when the macro is used but omitted. If the initial value is omitted, it will not be complemented.
			When specifying macro arguments, the side specified by #define is enclosed in parentheses, but when actually using it, specify it without parentheses.
		</p>
		<pre>; Example
#define hyouji(%1) mes "prm="+%1
    hyouji("AAAAA...")</pre>
		<p>
			Note that the above description will cause an error.
			However, by using the ctype option, the following description with parentheses becomes possible.
		</p>
		<pre>; Example
#define ctype kansu(%1) (%1*5+1)
    a=kansu(5)</pre>
		<p>
			This option is effective when you want to use a macro for something other than the command part, such as a calculation formula.
			At first glance, it behaves like a function in C language, but in reality it is just replacing it with a macro, so please note that the range of applications is narrow.
			Since this description method is different from the original HSP grammar, we do not recommend using it for anything other than customization purposes to describe in your own style.
		</p>
		<p>
			It is possible to set keywords that perform special actions during macro expansion.
			These special keywords are mainly for sharing parameters between different macros,
			or for realizing nested structures using a stack.
		</p>
		<pre>; Example
#define start(%1) %tstart %s1 mes "START"
#define owari %tstart mes %o</pre>
		<p>
			Here, "%s1" and "%o" etc. are special expansion macros.
			An example using these is expanded as follows.
		</p>
		<pre>start "OK"    → mes "START"
owari         → mes "OK"</pre>
		<p>
			In this way, it becomes possible to share data between different macros.
			The types and functions of special expansion macros are as follows.
		</p>
		<table class="keywordlist" summary="Introducing special expansion macros in a list format.">
			<caption>List of Special Expansion Macros</caption>
			<tr><th>Macro</th><th>Function</th></tr>
			<tr><td>%t</td><td>Set tag name</td></tr>
			<tr><td>%n</td><td>Generate a unique label name</td></tr>
			<tr><td>%i</td><td>Generate a unique label name and push it onto the stack</td></tr>
			<tr><td>%o</td><td>Retrieve the string pushed onto the stack</td></tr>
			<tr><td>%p</td><td>Retrieve the string pushed onto the stack (stack maintained)</td></tr>
			<tr><td>%s</td><td>Push the argument parameter onto the stack</td></tr>
			<tr><td>%c</td><td>Insert a line break</td></tr>
		</table>
		<p>
			Special expansion macros are expressed as "%" followed by one English letter + parameter.
			To distinguish them from subsequent keywords, be sure to insert a space after the special expansion macro.
			Everything up to and including the space, such as "%tabc aaa", will be considered a special expansion macro.
		</p>
		<p>
			Special expansion macros have a general stack (First In Last Out).
			This stack can be shared by macros with the same tag name.
			The tag name is specified by following "%t" with a 16-character (or less) English string, like "%tタグ名".
			In the previous example, "start" specified as "%tstart" is the tag name.
		</p>
		<p>
			"%s" is a special expansion macro for pushing argument parameters onto the stack.
			Specifying "%s1" pushes the parameter of "%1" onto the stack.
		</p>
		<p>
			To retrieve a string pushed onto the stack, use "%o".
			"%o" retrieves the string pushed onto the stack and expands it. Because it's a stack,
			the last item pushed is the first item retrieved. Specifying "%o0" will retrieve the stack
			but will not expand the string (stack retrieval only).
		</p>
		<p>
			"%p" retrieves only the content without removing it from the stack. "%p0" expands the contents of the next
			stack to be retrieved. "%p1" retrieves one stack level deeper. You can specify from "%p0" to "%p9".
		</p>
		<p>
			An example of label generation is shown below.
		</p>
		<pre>; Example
#define start %tstart *%i
#define owari %tstart await 20:stick a:if a=0 : goto *%o</pre>
		<p>
			An example using this is expanded as follows.
		</p>
		<pre>    start  → *_start_0000
    owari  → await 20:stick a:if a=0 : goto *_start_0000</pre>
		<p>
			"%i" generates a unique label name that does not overlap with others and pushes it onto the
			stack. Specifying "%i0" pushes the label name onto the stack but does not
			expand it. Also, "%n" generates a unique label name and expands it
			without pushing it onto the stack.
		</p>
		<p>
			In the example above, a new label is created by label name generation to
			realize a loop structure. By using this method, you can construct a loop structure
			where label names do not overlap even if they are nested.
			Also, if all stacks have not been retrieved in a single source script file,
			an error will be reported at compile time.
			Be sure to configure macro commands so that all stacks are retrieved and finished.
		</p>
		<p>
			*The standard defined macros while~wend, do~until, for~next are created by special expansion macros.
		</p>
		<p>
			In special cases, it is possible to expand by inserting line breaks with "%c".
			The line is divided and expanded at the "%c" part. It can be used for defining macros that are expanded into multiple preprocessor statements.
			However, not all preprocessors currently support macro expansion.
			If you overuse it, it may become difficult to read, so please use it with a good understanding.
		</p>
		<pre>; Example
    goto *@f
#define def(%1,%2) #deffunc %1 %c mes %2 %c return
    def test, a
*@
    a = 10
    test
    a = 20
    test
    stop</pre>


		<h3 id="HSPDEF">Standard Macro Definition File</h3>
		<p>
			The preprocessor always reads "hspdef.as" in the common directory as the standard
			macro definition at the beginning.
			Symbol names, macros, and basic
			modules defined by the system are planned to be added to "hspdef.as".
		</p>
		<p>
			Users should be careful not to edit "hspdef.as".
			If you want to customize it individually, you can prepare "userdef.as" and it will be
			automatically loaded in the same way as "hspdef.as". If the "userdef.as" file
			does not exist, it will not be applied.
		</p>
		<p>
			The standard macro definition file is searched in the following order. If the file is not found, it is ignored.
		</p>
		<ol>
			<li>"hspdef.as" in the directory where the source file is located</li>
			<li>"hspdef.as" in the common directory</li>
		</ol>
		<p>
			There are also macros that the preprocessor automatically adds.
			The following macros are automatically added, and it is possible to branch by distinguishing these
			macros with #ifdef, #ifndef instructions, etc.
		</p>
		<table class="keywordlist" summary="Introducing macros automatically added by the preprocessor in a list format.">
			<caption>List of Macros Automatically Added by the Preprocessor</caption>
			<tr><th>Instruction</th><th>Content</th></tr>
			<tr><td>_debug</td><td>In debug mode</td></tr>
			<tr><td>__hsp30__</td><td>When using ver3.0 or later</td></tr>
			<tr><td>__file__</td><td>File name being parsed at the time of use</td></tr>
			<tr><td>__line__</td><td>Line number being parsed at the time of use</td></tr>
			<tr><td>__date__</td><td>Date at the time of use</td></tr>
			<tr><td>__time__</td><td>Time at the time of use</td></tr>
			<tr><td>__hspver__</td><td>HSP version number (*)</td></tr>
			<tr><td>__runtime__</td><td>HSP runtime name</td></tr>
		</table>
		<p>
			*The upper 8 bits and lower 8 bits indicate the major and minor versions, respectively.
		</p>
		<p>
			Standard macros are provided to make descriptions easier for individuals to write.
			Use it if you want to write scripts in a format that you are already familiar with, such as the C language.
			In addition to operating in the same way as commands in appearance, it is also possible to define new
			macros in the same way. For details, see the separate section "<a href="#DEFINE_MACRO">About #define macros</a>".
		</p>
		<p>
			When running an old script, an error will occur if a newly added macro name is already used as a variable name or label name.
			Short words such as do, for, and next are likely to conflict, so be careful. If they conflict, you can make it work by replacing
			the variable name or label name with another one.
		</p>
		<h4>do〜until macro</h4>
			<p>
				Repeats the part from do to until until the condition following until is met.
				Even if the condition is met, the do〜until contents will be executed at least once.
				If the condition following until is omitted, it will not be repeated.
				You can also restart from the beginning of the loop with _continue, and escape the loop with _break.
			</p>
			<pre>; Example
    a=0
    do
        a=a+1
        mes "A="+a
    until a&gt;5    ; Repeats do and below until a is 5 or more</pre>
		<h4>while〜wend macro</h4>
			<p>
				Repeats from while to wend only while the condition following while is met.
				If the condition is not met, while to wend will not be executed.
				If the condition following while is omitted, it will repeat infinitely.
				You can also restart from the beginning of the loop with _continue, and escape the loop with _break.
			</p>
			<pre>; Example
    a=0
    while a&lt;5
        a=a+1
        mes "a="+a
    wend        ; Repeats while and below only while a is 5 or less</pre>
		<h4>for〜next macro</h4>
			<pre>for variable name, initial value(0), final value(0), increment(1)</pre>
			<p>
				By specifying as a parameter, the for〜next section is repeated the specified number of times.
				Values in parentheses are values when omitted. The variable name cannot be omitted.
				The specified variable is used as a counter, starting from the initial value,
				and the increment is added each time it is repeated. When the final value is reached,
				it exits the loop (the final value is not included in the loop).
			</p>
			<p>
				If the final value condition is met from the beginning, the repetition will not be executed.
				You can also restart from the beginning of the loop with _continue, and escape the loop with _break.
			</p>
			<pre>; Example
    for a,0,5,1
        mes "A="+a
    next        ; Repeats while a is between 0 and 4 (5 times)</pre>
			<p>
				In this example, the variable a repeats 0, 1, 2, 3, 4 five times and ends the loop.
				It is also possible to specify a negative value for the increment.
			</p>
			<pre>; Example
    for a,5,0,-1
        mes "A="+a
    next        ; Repeats while a is between 5 and 1 (5 times)</pre>
			<p>
				In this case, the variable a repeats 5, 4, 3, 2, 1 five times and ends the loop.
				The for macro generates a special new instruction exgoto internally after macro expansion.
				The exgoto instruction is an auxiliary instruction for the for macro and is not recommended for stand-alone use.
			</p>
		<h4>switch〜case〜swend macro</h4>
			<p>
				switch〜case〜swend is a construct that allows you to write multiple conditional judgments and processes together in a block.
				Start the switch block with <code>switch comparison source</code>.
				You can specify a variable or an expression as the parameter of the comparison source.
			</p>
			<p>
				After `switch`, placing `case comparison value` allows you to describe the content to be processed when the "comparison source" is the same as the "comparison value".
				Multiple `case` statements can be written within the block, and processing for each comparison value can be specified.
				If the `case` comparison is correct, the subsequent commands will be executed until `swbreak` is encountered.
				Also, if you put `default` instead of `case`, the subsequent code will be executed if none of the comparison values specified in `case` apply.
			</p>
			<p>
				When the `switch` block is finished, you must write `swend` at the end. The following is an example script using the switch macro.
			</p>
			<pre>; Example
    a=0
    switch a    ; Use a as the comparison target
    case 0        ; If a is 0
        mes "A=0"
        swbreak    ; End the execution of case 0 condition
    case 1        ; If a is 1
        mes "A=1"
    default        ; If a is not 0
        mes "A!=0"
        swbreak
    swend</pre>
			<p>
				In this example, the conditional branching is performed based on whether the content of variable a is 0, 1, or something else.
				After `case 0`, the code up to `swbreak` is executed, but in the case of `case 1`,
				because `swbreak` does not exist, `mes "A!=0"` executed after `default` will also be
				executed, so be careful.
			</p>

		<h3 id="CALL_API">API Call</h3>
		<p>
			HSP3 allows you to use the function to call functions exported by external DLLs.
			This is a function to call a DLL with pre-specified arguments,
			and it allows for flexible usage including HSP extension plugins from ver2.5 onwards.
		</p>
		<p>
			The overview of DLL calling is as follows.
		</p>
		<pre>#uselib "filename"			Specify external DLL</pre>
		<p>
			Specifies the filename of the external DLL to be called from HSP.
			The DLL filename must be written completely, including the extension.
			If the filename is omitted, the DLL will be linked from the script at runtime
			by specifying the DLL name.
		</p>
		<pre>#func NewName  FunctionName  Type		External DLL call command registration</pre>
		<p>
			Registers a new command to call an external DLL.
			Write the NewName, FunctionName, and Type separated by spaces.
			By enclosing the FunctionName with double quotes like "FunctionName", you can describe the complete
			export name of the DLL.
			If not enclosed in double quotes, it will be converted to the name based on the VC++
			export convention "_FunctionName@16".
		</p>
		<p>
			Type describes the details of the arguments.
			Similar to #deffunc, specify the argument type separated by commas.
			There are no restrictions on the number of arguments or the order of types.
			The following strings can be used as argument types.
		</p>
		<table class="keywordlist" summary="Introduces argument types in a list format.">
			<caption>List of argument types</caption>
			<tr><th>Type</th><th>Content</th></tr>
			<tr><td>int</td><td>Integer value (32bit)</td></tr>
			<tr><td>var</td><td>Variable data pointer (32bit)</td></tr>
			<tr><td>str</td><td>String pointer (32bit)</td></tr>
			<tr><td>wstr</td><td>Unicode string pointer (32bit)</td></tr>
			<tr><td>sptr</td><td>Pointer integer value or string pointer (32bit)</td></tr>
			<tr><td>wptr</td><td>Pointer integer value or unicode string pointer (32bit)</td></tr>
			<tr><td>double</td><td>Real number value (64bit)</td></tr>
			<tr><td>label</td><td>Label pointer (32bit)</td></tr>
			<tr><td>float</td><td>Real number value (32bit)</td></tr>
			<tr><td>pval</td><td>PVal structure pointer (32bit)</td></tr>
			<tr><td>bmscr</td><td>BMSCR structure pointer (32bit)</td></tr>
			<tr><td>comobj</td><td>COMOBJ type variable data pointer (32bit)</td></tr>
			<tr><td>prefstr</td><td>System variable refstr pointer (32bit)</td></tr>
			<tr><td>pexinfo</td><td>EXINFO structure pointer (32bit)</td></tr>
			<tr><td>nullptr</td><td>Null pointer (32bit)</td></tr>
		</table>
		<p>
			The following is an example of executing with four arguments specified.
		</p>
		<pre>; Example
#uselib "test.dll"
#func test "_func@16" var,int,int,int
    test a,1,2,3    ; test.dll's func(&amp;a,1,2,3) is called</pre>
		<p>
			Function import from DLL is performed when the command is first executed.
			If the imported function name is not found, an error will occur when you execute the command. (No error occurs at startup)
			The return value of the external API call is assigned to the system variable stat as a 32bit integer.
		</p>
		<p>
			If you specify a number for the type, arguments compatible with the DLL type specification from ver2.5 onwards
			will be automatically set.
			This allows you to use extension plugins up to HSP2.61 as they are.
			However, the following points require compatibility considerations with ver2.5.
		</p>
		<ul>
			<li>The BMSCR structure can only refer to fields from flag to color</li>
			<li>The PVal structure is compatible with the PVAL2 structure of ver2.5</li>
			<li>The flag field (type type value) and len field (array information) of the PVal structure cannot be rewritten by the DLL</li>
			<li>It is not possible to access string type array variables from the PVal structure</li>
		</ul>
		<p>
			In other respects, the same information as HSP ver2.5 is passed.
		</p>
		<p>
			Also, by putting "onexit" before the function name, it can be registered as a termination call function.
		</p>
		<pre>; Example
#func test onexit "_func@16" str,int,int</pre>
		<p>
			In the above example, "_func@16" is automatically called when the application ends.
		</p>
		<p>
			Similar to #func, it can also be registered as a function using the #cfunc command.
		</p>
		<pre>#cfunc NewName  "FunctionName"  TypeName1,…		External DLL call function registration</pre>
		<p>
			The argument parameters can use the same ones as the #func command.
			The NewName registered by the #cfunc command can be described in the expression as a function.
		</p>
		<pre>; Example
#uselib "test.dll"
#cfunc test "_func@16" var,int,int.int
    res=test(a,1,2,3)    ; test.dll's func(&amp;a,1,2,3) is called</pre>
		<p>
			The integer value (32bit int) acquired as a result of the external call is returned as the return value of the registered function as it is.
			In HSP2.5 compatible calls, the value returned to the system variable stat is used as the return value of the function.
		</p>

		<h3 id="COM_COMPONENT">COM Component Call</h3>
		<p>
			HSP3 allows you to use COM object type variables and the definition and
			calling of COM interfaces.
		</p>
		<p>
			To use the COM component function, you need to create a COM object type variable.
			Normally, you execute the newcom command to create a COM object type variable that corresponds to the specified COM class or
			interface. After that, you will be able to call methods through the created variable.
			COM object type variables store the interface pointer of the COM object,
			and the creation and destruction of the object are managed internally by HSP.
			(The delcom command to explicitly destroy the object is also available.)
		</p>
		<p>
			As the easiest way to use COM, access via automation is
			possible. This method can be used when using an
			automation object that provides the IDispatch interface.
		</p>
		<pre>; Example
    newcom ie, "InternetExplorer.Application"</pre>
		<p>
			In the above example, an object with the program ID (ProgID) "InternetExplorer.Application" is
			created, and the interface pointer of the object is stored in the variable ie.
			The program ID is the same as the class ID definition string used in VBScript, JavaScript, etc.
		</p>
		<p>
			Instead of the program ID, you can also specify the class ID in GUID format (a string in the format "{0002DF01-0000-0000-C000-000000000046}").
			After the COM object type variable is created, you can refer to and set properties, and call methods.
		</p>
		<p>
			In COM object type variables, you can refer to and set properties by specifying a string indicating the property as an array element.
		</p>
		<pre>; Example
    ie("Visible")=1</pre>
		<p>
			The above example sets the integer value 1 to the property named "Visible" of the variable ie initialized as a COM object.
		</p>
		<pre>; Example
    mes "Window position("+ie("Left")+","+ie("Top")+")"
    mes "Window size("+ie("Width")+","+ie("Height")+")"</pre>
		<p>
			The above example refers to and displays the contents of the property.
			The value of the property returned by the COM object is appropriately type-converted internally by HSP, and
			can be used as is.
		</p>
		<p>
			To execute a COM object's method, use the mcall command.
		</p>
		<pre>; Example
    mcall ie,"Navigate","https://www.onionsoft.net/"</pre>
		<p>
			The above example executes the method named "Navigate" by passing the string type argument "https://www.onionsoft.net/".
			The number of arguments and the type will be passed to the method as is.
			The return value of the executed method is assigned to the variable set by the comres command.
			Also, if the method execution is successful, the system variable stat will be 0, and if an error occurs, the result code (HRESULT value) will be assigned to the system variable stat.
		</p>
		<p>
			As a special description method of the mcall command, it is also possible to write as follows.
		</p>
		<pre>; Example
    ie-&gt;"Navigate" "https://www.onionsoft.net/"</pre>
		<p>
			Write the method name following the variable with "->", and specify the parameters.
			This is for those who want to use a description method similar to C++, etc.,
			and it is automatically replaced with the mcall command by the compiler.
		</p>
		<p>
			By specifying "$coclass" and "$interface" for the properties of the COM object, you can get the object's coclass name and interface name.
		</p>
		<pre>    pobj("$coclass")   : coclass name
    pobj("$interface") : interface name</pre>
		<p>
			It is also possible to directly call COM interface (custom interface) methods without using automation (IDispatch).
		</p>
		<pre>#usecom インターフェース名 "IID文字列" ["CLSID文字列"]	COM interface registration</pre>
		<p>
			To use a custom interface, define the interface name. Specify the interface ID in "IID文字列" as a string in GUID format (a string like "{000214EE-0000-0000-C000-000000000046}"). For "CLSID文字列", specify the class ID in GUID format as a string, but this can be omitted.
		</p>
		<p>
			If "CLSID文字列" is specified, you can specify that interface name as the second parameter of the newcom command. In this case, an object with the class ID of the #usecom command is created, the specified interface is acquired, and stored in the COM object type variable.
		</p>
		<pre>#comfunc 新規名称 メソッドインデックス タイプ名1,…		COM method registration</pre>
		<p>
			Immediately after defining an interface with the #usecom command, you can register COM methods and argument parameters with the #comfunc command. The type name specification is the same as for the #func command. If you specify wstr as the type name, you can pass a unicode (OLESTR) string as an argument to the method. (You can use the cnvwtos function to convert from unicode to HSP strings).
		</p>
		<pre>; Example
    ; Create a shortcut shortcut.lnk to hsp3.exe
    ;
    #define CLSID_ShellLink   "{00021401-0000-0000-C000-000000000046}"
    #define IID_IShellLinkA   "{000214EE-0000-0000-C000-000000000046}"
    #define IID_IPersistFile  "{0000010b-0000-0000-C000-000000000046}"

    #usecom IShellLinkA IID_IShellLinkA
    #comfunc IShellLink_SetPath 20 str

    #usecom IPersistFile IID_IPersistFile
    #comfunc IPersistFile_Save 6 wstr,int

    newcom slink, CLSID_ShellLink
    IShellLink_SetPath slink, dirinfo(1)+"\\hsp3.exe"
    IPersistFile_Save  slink, dirinfo(0)+"\\shortcut.lnk", 1

    mes "Shortcut created."
    delcom slink
    stop</pre>
		<p>
			In addition, the querycom command is available to query another interface from the generated interface. However, when executing the mcall command, the necessary interface is automatically queried, so if it is known in advance that the COM object provides the target interface, there is no need to explicitly execute the querycom command.
		</p>
		<p>
			Another way to create a COM object type variable is to use the axobj command to place ActiveX controls.
		</p>
		<p>
			The axobj command places the ActiveX control in the HSP window from the specified class ID (CLSID) or program ID (ProgID). The variable specified by the axobj command is initialized as a COM object type variable.
		</p>
		<pre>; Example
    axobj ie, "Shell.Explorer.2",640,480
    ie-&gt;"Navigate" "www.onionsoft.net"</pre>
		<p>
			The window generated by the axobj command is registered as a layout object managed by HSP. After executing the axobj command, the object ID is assigned to the system variable stat.
		</p>
		<p>
			The window generated by the axobj command is destroyed when the screen is initialized with the cls command, etc. It can also be explicitly destroyed with the clrobj command. However, the variable initialized as a COM object type variable remains as it is, so the user should destroy it. The COM object type variable is automatically destroyed when another value is assigned or when HSP terminates, so memory leaks etc. do not occur, but it is recommended to consciously destroy it because the COM pointer that has become unusable will remain.
		</p>
		<p>
			Note that to use the axobj command, Atl.dll or Atl71.dll must be installed in the execution environment. If these DLLs are not available, an error will occur.
		</p>
		<p>
			In addition, a function to manage COM events is available. This allows you to retrieve notifications of events notified from COM objects in a script.
		</p>
		<pre class="quote">comevent p1,p2,p3,*label

    p1      : Variable name to store the event management object
    p2      : Variable name of the event source
    p3      : Connection point GUID
    *label  : Label of the event subroutine</pre>
		<p>
			Prepares to retrieve an arbitrary event from the variable (COM object type) specified by p2. The COM object specified by p2 must have already been initialized by the newcom command. Initializes the variable specified by p1 as a special COM object type for performing event processing.
		</p>
		<p>
			Specify the connection point GUID as a string in p3.
			If p3 is omitted, the default connection point obtained by IProvideClassInfo2 is searched for.
		</p>
		<p>
			Specify the label of the event processing subroutine in *label.
			If the preparation for event acquisition fails, an error occurs.
			If successful, subroutine jump interrupts will occur at the location specified by *label each time an event occurs thereafter.
		</p>
		<p>
			In the event subroutine specified by *label, the details of the event can be acquired in detail using the comevdisp function and the comevarg command.
		</p>
		<p>
			If the comevent command is executed again for a variable for which event acquisition has already started, the previous event queue settings will be invalid. Event acquisition continues until the COM object is destroyed by the delcom command.
		</p>
		<pre>; Example
    #define IID_DWebBrowserEvents2 "{34A715A0-6587-11D0-924A-0020AFC7AC5D}"

    axobj ie, "Shell.Explorer.2", 640, 480
    comevent ie_event, ie, IID_DWebBrowserEvents2, *event
    stop
*event
    ;    COM event processing
    title "EVENT="+comevdisp(ie_event)
    return</pre>
		<p>
			In the example above, the event DWebBrowserEvents2 of the IE component is acquired, and the *event subroutine is called.
			The comevdisp function is used to retrieve the dispatch ID (DISPID) that identifies the type of event that occurred.
		</p>
		<p>
			Executing the comevarg command allows you to retrieve the parameters of the event.
		</p>
<pre class="quote">comevarg p1,p2,p3,*label

    p1 : Variable name to which the result is assigned
    p2 : Event management COM object variable name
    p3 : Parameter index (0〜)
    p4 : Acquisition mode (0=normal conversion, 1=conversion to string, 2=Variant type)</pre>
		<p>
			The event parameters (arguments) are acquired within the event processing subroutine of the variable specified by p2 (COM object type variable storing the event management object), and the result is assigned to p1. p3 is the index of the argument, and specifies 0 to get the first argument, and 1 to get the second argument. p3 is the acquisition mode, and if omitted or 0 is specified, it is converted to the HSP standard variable type. If 1 is specified, it is acquired in a state converted to a string. If 2 is acquired, it is acquired as the following Variant type variable.
		</p>
		<p>
			In HSP3, Variant type variables can be used as variable types for COM. Variant type variables are variables that store various types of data used in COM automation. It has been introduced in HSP3 so that the reference destination can be rewritten when a reference type (ByRef) variable is specified as a COM event parameter. It is also possible to acquire parameters that are not reference types as Variant type variables.
		</p>
		<p>
			Variant type variables can be acquired by specifying 2 as the fourth parameter when executing the comevarg command in the COM event processing subroutine. Like COM type variables, Variant variables can refer to the following values by specifying the property name. The case of property names is not distinguished.
		</p>
		<p>
			The following are special properties that can be referenced when variable v is a Variant type variable.
		</p>
		<!-- HTML構文上、定義型リストを使うべきか？ -->
		<pre>v("value") : Value stored in Variant</pre>
		<p>
	        Refers to the value stored in v. For example, if it is an integer type (VT_I4) Variant, then a = v("value") will make the variable a an integer type, and the value will be assigned. Assignment to v("value") is also possible.
	        It can also be referenced by v("val") or v("").
	    </p>
		<pre>v("isbyref") : Value indicating whether it is a reference</pre>
		<p>
	        Returns 1 if the Variant is a reference type (byRef).
	    </p>
		<pre>v("isarray") : Value indicating whether it is a SafeArray</pre>
		<p>
	        Returns 1 if the Variant is an array (SafeArray).
		</p>
		<pre>v("vartype") : VARTYPE value of Variant</pre>
		<p>
	        Refers to the VARTYPE value such as 2 (VT_I2), 3 (VT_I4), 8 (VT_BSTR).
	        Attempts to convert the type upon assignment (such as v("vartype")=2).
	        An error occurs if the type conversion fails. It can also be specified by v("vt").
		</p>
		<pre>v("vtmask") : Mask value of VARTYPE value of Variant</pre>
		<p>
	        Returns the value with VT_BYREF and VT_ARRAY removed from the VARTYPE value.
	    </p>
		<pre>v("refptr") : VARTYPE value of Variant</pre>
		<p>
	        Returns the reference pointer when v is a reference type (VT_BYREF).
	        An error occurs when v is not a reference type (VT_BYREF).
		</p>
		<p>
			In addition, Variant type variables can handle SafeArrays to some extent.
			The following properties are valid for Variant type variables storing SafeArrays.
		</p>
		<pre>v("value",n) : Value of element n of SafeArray</pre>
		<p>
	        Refers to the value of element n of the SafeArray. This example is for a one-dimensional SafeArray, for example, in a two-dimensional array it would be v("value",m,n). Simply using
	        v("value") will return a Variant type storing the SafeArray.
	    </p>
	    <pre>v("arraylbound",n) : Lower bound of element of dimension n of SafeArray
v("arrayubound",n) : Upper bound of element of dimension n of SafeArray
v("arraycount",n)  : Number of elements of dimension n of SafeArray</pre>
		<p>
	        Each returns the lower bound, upper bound, and number of elements of the specified dimension.
	        If n is omitted, 1 is specified.
		</p>
		<pre>v("arrayptr") : Pointer to SafeArray</pre>
		<p>
	        Gets the stored SafeArray (return value is an integer type).
	        Assigning a value stores the given SafeArray.
		</p>
		<pre>v("bstrptr") : Pointer to BSTR string</pre>
		<p>
	        Gets the stored string (BSTR) pointer.
	    </p>
	    <p>
			When getting properties of a COM object, putting a period before the property name
			will return the property as a Variant type. (The same applies to return values from
			method calls.)
		</p>
		<pre>    vname = pDoc(".Title")    ; vname is a Variant type
    name = vname("value")    ; name is a string type</pre>
		<p>
			The above example is the same as:
		</p>
		<pre>    name = pDoc("Title")    ; name is a string type</pre>
		<p>
			Also,
		</p>
		<pre>    dimtype a, vartype("variant"), 20</pre>
		<p>
			can be used to explicitly allocate a Variant type array.
		</p>
		<p>
			The sarrayconv command has been added for converting between Variant types and HSP arrays.
		</p>
		<pre class="quote">sarrayconv  p1, p2, p3, [p4]

    p1    : Variable to store the result
    p2    : Variable to convert from
    p3(0) : Conversion mode
    p4(0) : Size of binary data

    p3=0: Creates a SafeArray from the entire array variable p2 and
          stores it in the Variant type variable p1.
    p3=1: Stores the SafeArray stored in the Variant type variable p2 into the array variable p1.
          The region of p1 is reallocated.
    p3=2: Creates a SafeArray (VT_UI1 type) from p4 bytes of binary data from the variable p2 and
          stores it in p1.
    p3=3: Stores the binary data of the 1-dimensional SafeArray (VT_UI1 type
          or VT_I1 type) stored in the Variant type variable p2 into the variable p1.
          The region of variable p1 must be pre-allocated.</pre>

		<h3 id="AHT">HSP Template (AHT) Function</h3>
		<p>
			The HSP Template (AHT) function, which was added in HSP3.1 and later,
			provides various mechanisms for automatically generating source code and linking with external data.
		</p>
		<p>
			AHT has various roles.
		</p>
		<ul>
			<li>Defines the rules for automatically generating new HSP source scripts</li>
			<li>Defines the interdependencies between reusable HSP source scripts</li>
			<li>Defines data formats usable in HSP and the dependencies of their tools</li>
		</ul>
		<p>
			In other words, it supports a method for anyone to easily generate HSP source scripts, and a mechanism for easily using
			template scripts and tools.
		</p>
		<p>
			HSP has provided modules, macros, and plug-ins as means for reusing scripts.
			However, these have been created and published by individual users with their own rules.
			AHT aims to make it easier to reuse and link various standard scripts in a common way by formatting them according to defined rules.
		</p>
		<p>
			Templates are a new concept introduced in HSP3.1.
			The concept of a template used in general programming languages often refers to an advanced mechanism for abstracting code,
			but in the case of HSP, the focus is more simply on providing "templates" to be used to easily reuse scripts.
		</p>
		<p>
			AHT is a general term for a mechanism that includes information and tools for managing reusable HSP source scripts.
			Definition files used by AHT are called "AHT files" and have the extension ".aht".
		</p>
		<p>
			AHT files are compatible with HSP3 source script files (.hsp).
			AHT files can be compiled as HSP3 source as is.
			AHT files use preprocessor directives to specify definition information called the AHT header.
			It also defines a dialog interface using comments in a special format.
			AHT files are a format for easily reusing existing HSP3 source scripts as templates.
			With minimal modifications, existing scripts can be treated as AHT files.
		</p>
		<p>
			See the separate document <a href="aht.txt">aht.txt</a> for details on AHT.
		</p>


		<h3 id="VAR_EX">Variable Initialization and Protection</h3>
		<p>
			From HSP3.7 onwards, a mechanism has been introduced to perform safer variable operations and debugging.<br>
			Variables defined in the script can be freely read and written to after that point.
			At that time, there is a possibility of accidentally overwriting the contents of a variable that is already in use, or causing unexpected behavior by using a different variable name.
		</p><pre>
			a=1		; Assign 1 to variable a
			c=a+b		; Assign the sum of variable a and variable b to variable c
		</pre><p>
			For example, in the script above, variables a and c are initialized, but variable b is referenced without being initialized.
			In this case, variable b is treated as 0 (integer value), but it is best to avoid using it without initialization.
			There is also an option to display an error when an uninitialized variable is referenced. See <a href="#VAR_INIT">"Uninitialized Variable Detection"</a> for details.<br>
			Use one of the following methods to initialize variables.
		</p><pre>
		・Direct assignment to a variable (variable=value)
		・Initialization using dim, sdim, dimtype, ddim, ldim
		・Initialization using dup, dupptr
		・Initialization using #var, #varint, #vardouble, #varstr, #varlabel
		</pre><p>
			Other states are judged to be uninitialized.
			For example, directly returning a value to a specified variable, such as with the stick command, is not considered initialization.
			It is recommended to be aware of the variables you use and initialize them first so that you can manage them safely.<br>
			The #var, #varint, #vardouble, #varstr, #varlabel commands allow you to explicitly initialize and protect variables.
		</p>
		<pre>
		#var         Declare the variables to be used
		#varint      Declare the variable with its type fixed as integer (int)
		#varstr      Declare the variable with its type fixed as string (str)
		#vardouble   Declare the variable with its type fixed as real number (double)
		#varlabel    Declare the variable with its type fixed as label
		</pre>
		<p>
			These preprocessor directives should be written in a position before the variable is actually used, and declare that the variable is used in the script.
		</p>
		<pre>
			#var a,b,c
		</pre>
		<p>
			In the example above, variables a, b, and c are declared to be used.
			After that, it can be used as a variable that can be read and written.
			Multiple variable names separated by commas can be written together in the #var command.<br>
			Variables whose type is determined and are known not to be changed to another type can be declared with a fixed type.
			Variable declarations can only be written once at the beginning of the script. You cannot declare it again.
		</p>
		<pre>
			#varstr moji
		</pre>
		<p>
			In the example above, the variable moji is declared as a string type.
			After that, an error will occur if you try to assign a value that is not a string type.
			By fixing the type in advance, it is possible to prevent the variable type from being changed unintentionally.<br>
			The #varint, #vardouble, #varlabel commands are also used to declare variables with fixed types.
		<br>
		<br>
			These functions help manage variables when the scale of the script becomes large and it becomes difficult to grasp the whole picture.
			Variable initialization and declaration are not mandatory, but you should try to organize the variables you use.
			In the HSP script editor, it is possible to search for the location where the variable was initialized and the location where it is referenced using the <a href="#ALLREFERENCE">"Search All References function"</a>.
		<br>
		<br>
		The varprop command is provided for more advanced debugging of variable assignment. The varprop command can set variable type fixation, prohibition of assignment, etc.
		</p><pre>
			varprop Variable name,Setting value					Performs variable debugging settings

			Variable name : Variable name to perform debug settings on
			Setting value : Debug setting value (varprop_*)
		</pre><p>
			The varprop command supports safer variable operations and bug detection by individually specifying type fixing, value fixing, debugging log recording, etc. for the specified variable.
			Specify the variable name in the var parameter, and specify the debug setting value in the setting value parameter. The following macros can be used for the debug setting value.
		</p>
		<p>
		<table class="keywordlist" summary="Introduces the argument types in a list format.">
			<caption>List of macro names used for varprop command</caption>
			<tr><th>Macro name</th><th>Value</th><th>Contents</th></tr>
			<tr><td>varprop_xtype</td><td>1</td><td>Fix the variable type</td></tr>
			<tr><td>varprop_xvalue</td><td>2</td><td>Fix the variable value</td></tr>
			<tr><td>varprop_log</td><td>4</td><td>Enable variable debugging recording</td></tr>
			<tr><td>varprop_logarray</td><td>8</td><td>Enable array variable debugging recording</td></tr>
		</table>
		</p>
		<p>
			Each value can be specified simultaneously by adding them. If the setting value parameter is omitted or 0 is specified, all variable debug settings are canceled.
			If "varprop_xtype" is set, the variable type is fixed. From then on, the variable type will be prohibited, and an error will occur if the variable type is changed during execution.
			This will have the same behavior as when the variable type is fixed with the preprocessor command "#varint", etc.
		<br>
			If "varprop_xvalue" is set, the variable value is fixed to the value that was assigned at that point. From then on, an error will occur if the variable value is changed during execution.<br>
			This allows you to fix variable values and variable types and discover unintended variable initialization or value overwriting.
		<br>
			If "varprop_log" or "varprop_logarray" are set, variable debugging messages during variable assignment will be displayed in the debug window log.
		<br>
			Dedicated "logmesv" and "logmesva" commands are also available for variable debugging. Both have equivalent functionality to display messages in the debug window at the moment a variable is assigned.
			For details, refer to the <a href="#DEBUG_VARS">"Variable Debugging Messages"</a> section.
		<br>
			The varprop command, like the assert command, is intended to assist during debugging. Note that this command is disabled in executable scripts and platform-converted environments (iOS, Android).
		</p>


		<h3 id="HSPDEF2">Platform Macro Definitions</h3>
		<p>
			Starting with HSP3.7硫10a, a mechanism for identifying platform-specific information during compilation has been introduced.<br>
			To know which platform the current script is running on, it was necessary to refer to system variables such as hspstat or use the sysinfo function.
			This allows identification at runtime, but it is not possible to branch based on differences in plugins or environments at compile time.<br>
			Platform macro definitions are a mechanism to prepare platform-specific information as macros in advance during compilation.
			The following macros are set for each platform. Users can modify the source using preprocessor directives such as #ifdef and #ifndef.
		</p>
		<table class="keywordlist" summary="Shows the argument types in a list format.">
			<caption>Platform Macro Definition List</caption>
			<tr><th>Macro Name</th><th>Platform</th></tr>
			<tr><td>_hspwin</td><td>Windows</td></tr>
			<tr><td>_hspmac</td><td>MacOS</td></tr>
			<tr><td>_hsplinux</td><td>Linux</td></tr>
			<tr><td>_hspios</td><td>iOS</td></tr>
			<tr><td>_hspndk</td><td>Android</td></tr>
			<tr><td>_hspemscripten</td><td>Emscripten(html5/js)</td></tr>
		</table>
		<p>
		For example, if the macro "_hspwin" is defined, it can be assumed that the compilation is being done on the Windows platform.
		Note that this is not the platform on which it is running. Platform macro definitions indicate only the environment in which the script was compiled.
		(The Emscripten environment is defined when performing script conversion using HSP3Dish Helper).<br>
		For example, there are differences in plugins and commands that can be used in Linux and Emscripten environments. Use this as a means to absorb the differences in the HSP3 environment for each platform.
		If you want to change processing between Windows and Linux with the same script, you need to identify the platform at runtime using the conventional method.
		</p>


		<h2 id="HSP_BASIS">HSP Basic Operation Concepts</h2><br>
		<h3 id="TASK">HSP Tasks</h3>
		<p>
			HSP is a single-task interpreter that uses intermediate language processing.
			HSP and other Windows applications can run simultaneously in a multi-tasking environment.
		</p>
		<p>
			However, there is only one rule to remember when creating an HSP script for this purpose.
			In HSP, "in parts where there is a possibility of an infinite loop, such as not proceeding unless a key is pressed,
			you must always insert a wait or await command."
		</p>
		<p>
			wait and await commands play an important role in giving idle time to other Windows tasks.
			If you do not follow this rule, the infinite loop will take up almost all of Windows' tasks,
			affecting multi-tasking operation. As a result, the window may not be dragged properly,
			or task switching may not work properly, resulting in a strange state.
			(It will not become a fatal state where Windows itself stops working.
			If you accidentally create an infinite loop in HSP, press [Ctrl]+[Alt]+[Del] at the same time to
			end the HSP task to return to the original state.)
			However, there is no need to be too concerned about this rule. If it is a loop that will surely end within 1 second,
			there is no need to insert wait. Inserting wait will further slow down processing speed.
		</p>
		<p>
			The most problematic is when a part such as "wait until the mouse button is pressed" is,
		</p>
		<pre>; Example
*mwait
    getkey a,0
    if a=0 : goto *mwait</pre>
		<p>
			If described as above, it will become an infinite loop there. This can be changed to,
		</p>
		<pre>; Example
*mwait
    getkey a,0
    await 5
    if a=0 : goto *mwait</pre>
		<p>
			If corrected in this way, the infinite loop will be avoided and the task will be executed normally.
			"await 5" is a very short wait, so it will not make it difficult to input buttons.
		</p>
		<p>
			The await command is an instruction to keep the passage of time in the loop constant.
			To wait for the specified time, use the wait command.
			The burden on the CPU (Windows) is the same for both the await command and the wait command.
		</p>

		<h3 id="SCR_AND_WND">Screen and Window</h3>
		<p>
			The central function of HSP is to draw characters, images, points, and lines on the screen.
			HSP provides multiple drawing buffers, each with a
			window assigned, allowing you to manipulate multiple window screens.
		</p>
		<p>
			HSP can have multiple virtual screens that are the target of drawing.
			These virtual screens are managed by a number called the window ID.
		</p>
		<p>
			Window ID 0 refers to the first screen that appears. If you do not open more than two windows,
			you can use the window ID without being particularly aware of it.
		</p>
		<p>
			To open a new window separate from the HSP main screen, or to create a virtual
			screen in memory, you will use window IDs 1 and later.
			There are no restrictions on the value of the window ID, but try to use them in order from ID1.
		</p>
		<p>
			New virtual screens must be initialized before use. The commands for this are
			the screen and buffer commands. Initializing with the screen command
			displays that screen as a new window on the display.
			(This window can be resized by default.)
			In contrast, initializing with the buffer command makes the screen only exist in memory,
			and its contents are not visible on the display. Such a
			screen can be used as a temporary storage location for copying part of an image to another screen.
		</p>
		<p>
			After initializing the window ID with commands such as screen or buffer, you can
			draw freely on that screen. There are various commands available, such as displaying characters with the mes command,
			filling with the boxf command, and drawing straight lines with the line command.
			If you are using multiple window IDs, you can change the drawing target with the gsel command.
			It is also possible to copy images drawn on screens with different window
			IDs using the gcopy or gzoom command.
		</p>
		<p>
			The screen can be reinitialized with the cls command.
			It is also initialized when an image is loaded with the picload command.
			When quickly switching the entire screen to perform animations, etc.,
			turn OFF the redraw switch with the redraw command, rewrite the screen,
			and then turn the redraw switch ON. This prevents the
			results of screen rewriting from being reflected on the screen, allowing for smooth and fast rewriting.
			Also, when rewriting, do not use the cls command, but clear the screen with the
			boxf command, etc.
		</p>

		<h3 id="PRINT">Font and Character Display</h3>
		<p>
			The most basic and simple command for displaying characters is mes(print).
			The mes command and the print command have the same function. (The keyword print can also be used to match the traditional BASIC syntax, but the mes command is recommended in HSP3.)<br>
			Following the mes command, specify the string you want to display on the screen enclosed in "" (double quotation marks).
		</p>
		<pre>; Example
			mes "Hello!"</pre>
		<p>
			The above example displays "Hello!". The display position is referenced by the current position specified by the pos command.
			After displaying the characters, the current position automatically moves to the next line. However, it is also possible to move it behind the last character depending on the option settings.<br>
			The font that is displayed is the standard font that is set, but the font can be changed using the font command.
		</p>
		<pre>; Example
			font msgothic,20,1</pre>
		<p>
			The above example changes to a 20-point size MS Gothic font with a bold setting.
			When characters are displayed with the mes command after this, they will be in the specified font.<br>
			The font command has the following parameters.
		</p>
		<pre>
			font "fontname",p1,p2,p3
			"fontname"   : Font name
			p1=1鐔12)   : Font size
			p2=0〜(0)    : Font style
			p3=1〜(1)    : Font modification width</pre>
		<p>
			In the font name, you can specify the installed font name.
			In Windows, you can specify the standard installed fonts by macro name. If you write msmincho, "ＭＳ 明朝" will be selected, and if you write msgothic, "ＭＳ ゴシック" will be selected.<br>
			The font size is specified in logical size proportional to the number of dots.
			The larger the number, the larger the characters. The font style is,
		</p>
		<pre>
			  Style 1  : Bold
			  Style 2  : Italic
			  Style 4  : Underline
			  Style 8  : Strikethrough
			  Style16  : Anti-aliasing</pre>
		<p>
			You can specify the value of. You can also specify multiple styles at the same time by summing the numbers. If the p2 parameter is omitted, it will be 0 (normal style).<br>
			The parameters of the mes command are as follows.
		</p>
		<pre>
			mes "strings",sw
			"strings" : Message or variable to display
			sw(0)     : Options</pre>
		<p>
			The first parameter of the mes command can be a string or a variable name. If a variable name is specified, the content assigned to the variable will be displayed.<br>
			The second optional parameter allows you to set character modifications and behavior.
		</p>
		<pre>
			   Value : Macro Name       : Action 
			 -----------------------------------------------------
			   1   : mesopt_nocr    : No newline at the end
			   2   : mesopt_shadow  : Draw shadowed characters
			   4   : mesopt_outline : Draw outlined characters
			   16  : mesopt_gmode   : Reflect gmode settings (HSP3Dish only)</pre>
		<p>
			If you specify 2 or mesopt_shadow for the option, shadowed characters will be drawn.
			If you specify 4 or mesopt_outline for the option, outlined characters will be drawn.
			The color specified by the objcolor command is used for the shadow and outline.
			Also, the width of the shadow and outline can be specified by the 4th parameter of the font command.
		</p>
		<p><center><img src="img/s_mesopt.png"></center></p>
		<p>
			In the example above, the left is shadowed characters, the center is outlined characters, and the right is normal characters.
			If you specify 16 or mesopt_gmode for the option, drawing will reflect the settings for transparency, color addition, etc. specified by gmode.
			(This option is only valid for HSP3Dish and HGIMG4. It is ignored in the normal HSP3 runtime.)<br>
			Multiple options can be specified simultaneously by adding their values.
			If "mesopt_nocr+mesopt_shadow" is specified, the display will be shadowed and without a newline.
		</p>


		<h3 id="IMG_FILE">Using Image Files</h3>
		<p>
			Image files in standard image formats can be loaded and used as
			image data for display within the screen.
		</p>
		<table class="keywordlist" summary="This list introduces image file formats that can be used as standard with HSP.">
			<caption>Image file formats available as standard with HSP</caption>
			<tr><th>Extension</th><th>Format</th></tr>
			<tr><td>bmp</td><td>Windows standard bitmap image data</td></tr>
			<tr><td>png</td><td>PNG format image compression data</td></tr>
			<tr><td>jpg</td><td>JPEG format image compression data</td></tr>
			<tr><td>gif</td><td>GIF format image compression data (excluding animations)</td></tr>
			<tr><td>ico</td><td>Windows standard icon image data</td></tr>
		</table>
		<p>
			Images are loaded using the picload or celload command.
			By specifying a file name, the format is automatically identified and loaded.
			It is also possible to load images from file data existing in memory by using the memory stream function.
			For the png format, it can be loaded using the COM function.
			See "HSP3 Support Module" for details.
		</p>


		<h3 id="CUR_POSITION">Current Position</h3>
		<p>
			Message output, graphic data copying, and button placement are performed at
			the location referred to as the current position.
		</p>
		<p>
			The current position is like the cursor in a text editor, and
			after a message is output, the current position also moves automatically to the next line after a newline.
			The current position can be changed by the pos command. Also,
			the amount of movement of the current position can be adjusted by the objsize command.
			When the screen is initialized with the cls command, the current position is also reset to (0,0).
		</p>

		<h3 id="GUI_OBJECT">Arranged Objects</h3>
		<p>
			In HSP, parts such as push buttons and input boxes are called arranged objects, and they can be freely arranged within the screen.
			HSP can use the following objects as standard.
		</p>
		<table class="keywordlist" summary="This list introduces objects that can be used as standard with HSP.">
			<caption>Objects available as standard with HSP</caption>
			<tr><th>Object Name</th><th>Arrangement Command</th><th>Content</th></tr>
			<tr><td>Button</td><td>button</td><td>Executes the program of the specified label when pressed</td></tr>
			<tr><td>Input Box</td><td>input</td><td>Enter numerical values and strings</td></tr>
			<tr><td>Message Box</td><td>mesbox</td><td>Enter multi-line strings</td></tr>
			<tr><td>Check Box</td><td>chkbox</td><td>ON/OFF Checkmark switching</td></tr>
			<tr><td>Combo Box</td><td>combox</td><td>A frame from which multiple elements can be selected</td></tr>
			<tr><td>List Box</td><td>listbox</td><td>A frame from which multiple elements can be selected</td></tr>
			<tr><td>Layer Object</td><td>layerobj</td><td>User-defined drawing object</td></tr>
		</table>
		<p>		
			Each object is assigned and managed by a number called the object ID.
			The object ID is an integer value starting from 0, and it is assigned to the system variable stat after the execution of the placement command. Usually, numerical values 0, 1, 2, 3... are automatically assigned in the order they are placed on the screen.
		</p>
		<p>
			Object IDs are needed when you want to erase some of the object later, or change its state.
			Also, when a push button is pressed, the object ID of the pressed button is assigned to the system variable stat.
		</p>
		<p>
			Objects can be easily placed and used, but if you master a deeper usage,
			it becomes possible to write more advanced scripts.
			The objprm command for changing the contents of an object later, and the sendmsg command for sending Win32 messages directly to the object, are commands prepared for such advanced usage.
		</p>
		<p>
			In addition to the placement objects listed here, Windows-supported controls can be added with
			the winobj command, and ActiveX controls can be directly added with the axobj command.
		</p>


		<h3 id="LAYER_OBJECT">Layer Objects</h3>
		<p>
			Layer objects are placement objects defined by the user.
			By registering subroutines that perform drawing on the screen in advance, you can execute drawing at a specified timing (layer).
		</p>
		<PRE>
		　Example :
				layerobj 320,240,objlayer_normal,*laysub,100
				stop
			*laysub
				return
		</PRE>
		<p>
			Layer objects themselves have no function.
			It manages a specific area on the screen as a layer object, and calls the user's program (callback routine) for each drawing timing.
			There are various ways to use it, but it is possible to manage only the drawing part independently with modules added later.<br>
			It is also possible to receive parameters with the objprm command, and to install or create your own placement objects.<br>
			The layerobj command is written in the following format.
		</p>
		<PRE>
			layerobj p1,p2,p3,*label,p4
			p1,p2     ; XY size of the layer object (in dots)
			p3(0)     : Layer ID
			*label    : Layer object processing subroutine
			p4=0〜(0) : Option value
		</PRE>
		<p>
			In order to notify the drawing area to the layer object, it is necessary to specify the X and Y sizes in dots with p1 and p2. If the specification of p1 and p2 is omitted, the size of the entire screen will be used.
			Now, with the current position X, Y as the upper left coordinates, the size specified by p1 and p2 is treated as a layer object.
			Specify the layer to draw in the p3 parameter.
		</p>
		<PRE>
			  p3 : Layer to draw
			 --------------------------------------------------------------
			    0 : Do not draw (objlayer_min)
			    1 : Background layer (objlayer_bg)
			    2 : Normal drawing layer (objlayer_normal)
			    3 : GUI layer (objlayer_posteff)
			    4 : Topmost drawing layer (objlayer_max)
			 +256 : Allow duplicate registration of layer objects (objlayer_multi)
		</PRE>
		<p>
			Specify the processing subroutine of the layer object with the *label parameter.
			This subroutine must be prepared by the user.
			With the p4 parameter, you can set an arbitrary integer value to be set for the layer object.<br>
			The processing subroutine of the layer object specified by the *label parameter is,
			It is called at various timings. This subroutine needs to follow the specifications called <a href="#CALLBACK">callback routine</a>. (You cannot write commands that wait for time, such as wait, await, stop, etc.)<br>
			When the processing subroutine is called, necessary information is assigned to the system variables iparam, wparam, and lparam, so please describe the processing according to this content.
		</p>
		<PRE>
			System Variable  : Content
			---------------------------------------------------------------
			iparam        : Passed parameter
			wparam        : Placement object ID
			lparam        : Call factor
		</PRE>
		<p>
			In the processing subroutine, first check the call factor assigned to lparam and perform the processing according to it.
			The call factor is one of the following values.
		</p>
		<PRE>
			   Value : Call factor (Macro Name)
			 --------------------------------------------------------------
			    1 : Newly installed (objlayer_cmdinit)
			    2 : Before the object is deleted (objlayer_cmdterm)
			    3 : int value passed by objprm command (objlayer_cmdprmi)
			    4 : String passed by objprm command (objlayer_cmdprms)
			    5 : double value passed by objprm command (objlayer_cmdprmd)
			    6 : Timing to draw (objlayer_cmddraw)
			    7 : A certain amount of time has passed (Not implemented) (objlayer_cmdtime)
		</PRE>
		<p>
			You do not necessarily need to process all the call factors.
			Process only the necessary factors and quickly return the processing to the system with the return command.<br>
			1 is called immediately after the layerobj command is executed, and 2 is called immediately before the object is discarded by the clrobj command, etc.
			3 to 5 are called when a value is passed by the objprm command. The value changes depending on the type of value, so you need to respond accordingly.
			In the case of int value, iparam. In the case of string, refstr, and in the case of double value, the passed value is assigned to refdval respectively.<br>
			6 is called at the appropriate timing when the redraw command is executed.
			This is the timing to draw the layer specified as the layer to draw by the layerobj command in advance.<br>
			Please draw on the valid drawing screen with the drawing command. (It is not always necessary to draw.)
			The redraw command is not necessary for drawing. You can use arbitrary drawing commands such as boxf command and mes command.<br>
			The drawing area allocated to the layer object must be acquired by the user from the object information and the range must be taken into account.
			You can use the objinfo function to get the drawing range with a script like this.
		</p>
		<PRE>
			; Gets the top-left X,Y coordinates (x,y) of the drawing
			i=objinfo(wparam,objlayer_info_axis):x=i&0xffff:y=i>>16
			; Gets the X,Y size (sx,sy) of the drawing
			i=objinfo(wparam,objlayer_info_size):sx=i&0xffff:sy=i>>16
		</PRE>
		<p>
			In the example above, the X,Y coordinates of the top-left are assigned to variables x,y, and the X,Y size is assigned to variables sx,sy.<br>
			Layer objects can be used with the HSP3 standard runtime, HSP3Dish, and HGIMG4 runtime.
			In the HSP3 standard runtime, other placed objects are drawn by the Windows system, so they cannot be affected.
			In the HSP3Dish and HGIMG4 runtimes, all placed objects are drawn on the main screen, allowing for more free control of drawing priority.
			It can be used for various purposes such as fade-in/out, post-effects, and processing of already drawn screens.
		</p>


		<h3 id="CUR_COLOR">Current Color</h3>
		<p>
			The current color is the color used for outputting messages, drawing points, lines, rectangles, etc.
			This can be changed with the color, rgbcolor, hsvcolor, and palcolor commands.
		<PRE>
		　Example :
			color 100,200,300	; Sets R=300, G=200, B=300
			hsvcolor 10,20,30	; Sets the color in HSV format
			rgbcolor $112233	; Sets the color in 32-bit RGB format
			palcolor 20		; Sets the color using palette color
		</PRE>
			When the screen is initialized with the cls command, the current color is reset to black.
			Also, the color of the specified coordinates can be set as the current color by the pget command.<br>
			The RGB of the current color can be referenced by the system variables ginfo_r, ginfo_g, and ginfo_b, respectively.
		</p>


		<h3 id="CEL_FUNCTION">About CEL Related Commands</h3>
		<p>
		Cell drawing commands for displaying 2D characters are available.
		This has a clear description and structure that replaces the conventional gcopy command.
		<BR><BR>
		Cell drawing commands reduce the drawing cost of characters and clearly separate
		the materials. Of course, the conventional gcopy command can be used for display in the same way.
		<BR><BR>
		Cell related commands consist of celload, celdiv, and celput commands.
		The celload command is used to load the image (texture) for display from a file.
		Similar to the picload command, it expands the specified image file into memory, but
		the loading destination buffer can be specified.
		<PRE>
		　Example :
			celload "a.png",1
		</PRE>
		In the example above, the image "a.png" is loaded into window ID 1.
		This initializes the window ID 1 with the buffer command and loads the image with the picload command
		at once.
		In addition, the celload command allows loading into an empty window ID.
		<PRE>
		　Example :
			celload "a.png"
			id = stat
		</PRE>
		In the example above, the window ID loaded is assigned to the variable id.
		When the parameter of the window ID is omitted in this way, an ID is automatically assigned,
		and the value is assigned to the system variable stat.<BR>
		At this time, if the same file name as the already loaded image file is specified,
		the loaded window ID is reused.
		(If you do not want to reuse the window ID, specify "celload "a.png",celid_auto")
		<BR><BR>
		The loaded image can be drawn in whole or in part by the celput command.
		The celput command provides a drawing method similar to 2D sprites.
		<PRE>
		　Example :
			celload "a.png",1
			pos 100,100
			gmode 2
			celput 1
		</PRE>
		In the example above, the image in window ID 1 (the image of "a.png") is placed at the position (100,100),
		and drawn in copy mode 2.
		The drawing position is the current position set by the pos command.
		The size of the drawn image is the entire image (the size of window ID 1).
		To change this, use the celdiv command (described later).
		<BR><BR>
		The celput command also has several other parameters.
		<PRE>
			celput id,no,zoomx,zoomy,angle

			id=0〜(1) : Window ID with image material
			no=0〜(0) : Divided image No.
			zoomx=0.0〜(1.0) : Horizontal display magnification (real number)
			zoomy=0.0〜(1.0) : Vertical display magnification (real number)
			angle=0.0〜(0.0) : Rotation angle (unit is radians)
		</PRE>
		With zoomx, zoomy, and angle, you can set scaling and rotation for the original image material.
		If the zoomx, zoomy, and angle specifications are omitted, or if the magnification is set to equal (1,1,0),
		high-speed copying is automatically executed internally. Conversely, if drawing is not at equal magnification,
		drawing processing similar to the groate command is executed.
		<BR><BR>
		At the time of drawing, the copy mode and transparency can be specified by the gmode command.
		The same options as the gcopy command and the groate command can be specified.
		However, note that the copy size specified by the gmode command is not reflected in celput.
		<BR><BR>
		After drawing, the current position is moved to the right according to the drawn size.
		<PRE>
		　Example :
			repeat 5
			celput 1
			loop
		</PRE>
		In the example above, the same image is drawn side by side in five copies.
		<BR><BR>
		The material of the original image can be divided into multiple parts with a determined size.
		The celdiv command is a command for setting the size division of parts for each window ID.
		<PRE>
		　Example :
			celload "a.png",1
			celdiv 1,64,64
		</PRE>
		In the example above, the image of window ID 1 is divided into image parts of 64 x 64.
		The celput command draws with the divided size.
		For example, if a 256 x 256 dot image is divided into 64 x 64 dot units,
		it is treated as 16 images (the whole is divided into 4 x 4).
		The divided image is specified by the second parameter of the celput command.
		Here, the "divided image No." specified is a numerical representation of the divided area as 0, 1, 2...
		When dividing into 4 x 4, the numbers are assigned in the following order.
		</p>
		<table class="keywordlist">
			<tr><th>0</th><th>1</th><th>2</th><th>3</th></tr>
			<tr><th>4</th><th>5</th><th>6</th><th>7</th></tr>
			<tr><th>8</th><th>9</th><th>10</th><th>11</th></tr>
			<tr><th>12</th><th>13</th><th>14</th><th>15</th></tr>
		</table>
		<p>		
		The celdiv command also has a function to set the base point position of the drawing.
		Normally, like the gcopy command, the celput command also draws a rectangle from the drawing position (coordinates specified by the pos command)
		towards the lower right.
		However, by setting the base point position of the drawing, you can freely change the drawing position to be the center of the original image,
		or to the lower right. The rotation also takes place around this base point.
		<PRE>
		　Example :
			celload "a.png",1
			celdiv 1,64,64,32,32
		</PRE>
		In the example above, the image of window ID 1 is divided into 64 x 64 parts,
		and the drawing base point (center) is set to (32, 32), that is, the center.
		</p>
		<p>
		The division setting of the image material is saved for each window ID, and is initialized by the cls command.
		At this point, the setting is no division (the entire screen is specified as the size).
		Be sure to make the division setting in a state where the image material is loaded into the specified window ID.
		If you load the image material after making the division setting, the division setting will be reset.
		</p>


		<h3 id="INPUT">Getting Input</h3>
		<p>
			HSP has various methods available for receiving input from the user.
			It is possible to capture basic GUI parts (placed objects), input from the mouse, and information from keyboards and connected devices.
			The following is an example of a script that enables numerical input using GUI parts (placed objects) and displays the contents.
		</p>
		<pre>Example:
				a=1
				input a
				button "OK",*ok
				stop
			*ok
				mes a
				stop</pre>
		<p>
			By using placed objects, you can easily get input from the user.<br>
			In addition, commands are also available to directly check the status of the keyboard and mouse.
		</p>
		<pre>
			Commands to get input  :  Content
			-------------------------------------------------------
			  getkey        :  Gets information about whether a specific key on the keyboard is pressed
			  stick         :  Gets keyboard information often used in games, etc.
			  onkey         :  Receives input each time a key is pressed
			  onclick       :  Receives input each time a mouse button is pressed
			  mousex        :  Gets the X coordinate of the mouse (system variable)
			  mousey        :  Gets the Y coordinate of the mouse (system variable)</pre>
		<p>
			In addition to this, various functions are available, such as acquiring connected devices and the results of communication.
			Gamepads (joysticks) used in games, etc., are acquired using the extended modules
			mod_joystick.as and mod_joystick2.as. For details, see the help for the jstick command.
		</p>


		<h3 id="MEM_BUFFER">Using Memory Buffers</h3>
		<p>
			The memory space held by a variable can be used as a memory buffer for handling data.
			This can be used when processing various formats such as strings with indefinite data length and binary data.
		</p>
		<p>
			The size of the memory buffer managed by a variable is variable in length, and as much memory as Windows allows
			can be handled, and there is no upper limit.
			The memory buffer can usually be secured with the sdim command.
			(To expand the size in the middle, use the memexpand command.)
			File input/output of the memory buffer is usually performed with the bload command and the bsave command.
		</p>
		<p>
			Also, the noteload command and the notesave command are available for handling text files.
			For details, see the "Memory Notepad Command" section.
			Whether the target is a text file or binary data, the handling of the memory buffer is basically the same.
		</p>
		<p>
			For data in the memory buffer, direct access is possible with the poke command, the wpoke command, the lpoke command, etc.
			and the contents can be read out by the peek function, the wpeek function, and the lpeek function.
			In addition, the memcpy command and the memset command are available to copy and fill data together.
		</p>
		<p>
			When dealing with external DLLs or programs, the pointer of the memory buffer that a variable handles can be obtained using the varptr function.
			Also, the size of the memory buffer that a variable handles can be obtained using the varsize function.
		</p>


		<h3 id="PLAY_MULTIMEDIA">Multimedia Playback</h3>
		<p>
			HSP3 allows you to easily handle WAV format PCM audio files, SMF (MID) format standard MIDI files,
			CD audio track playback, AVI/MPEG video files, and compressed audio files such as MP3/WMA.
			It is also possible to control devices registered as MCI control devices.
		</p>
		<p>
			The file to be played is registered in HSP using the mmload command, and playback can be started using the mmplay command (playback interruption is done with the mmstop command).
			For each sound, you can select loop playback or waiting until the end of playback.
		</p>
		<p>
			However, there are problems with MIDI loop playback, and it will not be a perfect loop performance.
			This is because the Windows MIDI sequencer takes time to start playing, and MIDI data often takes time to initialize the sound source or specify the timbre,
			so the transition from the end of the performance to the loop is often not smooth.
		</p>
		<p>
			Therefore, please understand that this function is only a simple loop.
			You can use it with reservations because you cannot specify a loop pointer.
		</p>
		<p>
			Depending on the MIDI device driver, Windows may freeze or the MIDI performance may not be played if you start the MIDI performance again immediately after stopping the MIDI performance.
			In such cases, try inserting a wait of about 1-2 seconds (e.g., wait 20) after the end of the MIDI performance before starting the next performance.
		</p>
		<p>
			WAV format PCM audio is played back after being loaded into memory first, so loop playback works without problems. However, because the WAV file size occupies memory, use the mci command to play extremely large files.
		</p>
		<p>
			By handling ogg format compressed audio files from the hspogg plugin,
			it is possible to achieve memory-efficient and perfect loop playback.
		</p>

		<h3 id="VAR_INIT">Uninitialized Variable Detection</h3>
		<p>
			It is possible to detect uninitialized variable references during script compilation.
			An uninitialized variable reference refers to reading the contents of a variable that has not been assigned a value.
		</p>
		<pre>
		a=1:b=2		; Initialize variables a and b
		c=a*b+x		; Variable x is not initialized
		</pre>
		<p>
			For example, in the above example, variables a and b have values assigned to them,
			but variable x has not yet been assigned a value at the time of the calculation "c=a*b+x".
			In HSP, in such cases, the contents are treated as 0, and variables can be used casually even without assigning a value. However, this also has disadvantages.
		</p>
		<pre>
		hensu=1		; Initialize variable hensu
		kotae=hensuu*2	; Calculate the value multiplied by 2
		</pre>
		<p>
			In the example above, we are trying to calculate the value of variable hensu multiplied by 2,
			but we mistakenly typed "hensuu". Even in such a case, the calculation is
			executed, but the variable hensuu is 0, so the calculation result will not be as expected.
			These mistakes due to typing errors are difficult to find
			and can cause bugs.
		</p>

		<p>
			The HSP compiler detects these references at compile time.
			In the script above, if you press the [F7] key to display the report,
			the following warning will be displayed.
		</p>
		<pre>
		#Uninitialized variable found (hensuu)
		</pre>
		<p>
			In the standard state, it only issues a warning in the report, but you can change this to treat it as an error.
		</p>
		<pre>
		#use strict		; Treat uninitialized variable references as errors
		</pre>
		<p>
			As above, you can use the preprocessor command #use to treat uninitialized variable references as errors.
			If you want to control the handling of errors in detail, use the #comopt command.
			The settings by #comopt are reflected in the lines after that.
		</p>
		<pre>
		#cmpopt varinit 1	; Treat uninitialized variable references as errors
		</pre>
		<p>
			This allows you to control the setting to treat only a part as an error.
			If you do not want to treat it as an error, describe it as follows.
		</p>
		<pre>
		#cmpopt varinit 0	; Do not treat uninitialized variable references as errors
		</pre>
		<p>
			For example, describe the script as follows.
		</p>
		<pre>
		#use strict	; Treat uninitialized variable references as errors
		hensu=1		; Initialize variable hensu
		kotae=hensuu*2	; Calculate the value multiplied by 2
		</pre>
		<p>
			In this case, the following error message will be displayed and it will not be executed.
		</p>
		<pre>
		???(3) : error 39 : An attempt was made to use an uninitialized variable (line 3)
		--> kotae=hensuu*2
		</pre>
		<p>
			For details on variable initialization, see <a href="#VAR_EX">"Variable Initialization and Protection"</a>.
		</p>


		<h3 id="CONSOLE">Console Version of HSP</h3>
		<p>
			HSP3 comes standard with a runtime that only displays text and operates on the command prompt.
			The console version of HSP (HSPCL) can be used in the following situations.
		</p>
		<ul>
			<li>Perform simple processing as a substitute for batch files</li>
			<li>Execute CGI on a Windows-based web server</li>
			<li>Execute HSP scripts with lighter memory and CPU load</li>
		</ul>
		<p>
			When using HSPCL, add the following line to the beginning of the script.
		</p>
		<pre>#runtime "hsp3cl"</pre>
		<p>
			The runtime will switch, and it will automatically operate on the command line.
			Note that commands related to windows, objects, and multimedia cannot be used.
			Samples for HSPCL are included in the sample/hspcl folder, and
			samples for operating as CGI are in the sample/hspcl/cgi folder.
		</p>
		<p>
			HSPCL has a dedicated input command implemented. The format is as follows.
		</p>
		<pre class="quote">input p1,p2,p3                Get standard input

p1=Variable name  : Variable name to store information
p2=1〜     : Maximum number of characters to be assigned to the variable
p3=0〜(0)  : Newline code recognition flag (0=None/1,2=Recognize)

・Description

    The contents of standard input are assigned to the variable specified by p1.
    The variable specified by p1 is changed to a string type and the result is assigned.
    In this case, the size of the string is up to the number of characters specified by p2.
    If the specification of p2 is omitted, the maximum value that can be assigned to the variable will be used.
    If p3 is omitted or 0 is specified, all of standard input (up to EOF) will be
    obtained as is. If 1 is specified for p3, the newline code (13) will be
    recognized as the end. When using keyboard input (console) as standard input,
    by setting p3 to 1 or 2, input can be confirmed with the [Enter] key.
    (If p3 is 1, LF is recognized as a newline, and if it is 2, CR+LF is recognized as a newline)
    Normally, it acquires up to the string terminator (character code 0), but by adding
    16 to the value of p3, all of the standard input buffer contents including character code 0
    are taken into the variable buffer. Be sure to specify this when acquiring code containing 0, such as binary data.</pre>
		<p>
			The number of characters in the input result is saved in the system variable strsize.
		</p>
		<p>
			Other functions can be used as HSP3 equivalent.
			Extension plugins and COM-related commands can also be used. (However, an operation error may occur if the plugin side acquires and uses the BMSCR structure.)
			Executable file creation, data file embedding, and encryption are also supported.
		</p>

		<h3 id="ON_EVENT">Interrupts</h3>
		<p>
			Interrupt processing due to various factors is supported.
			The following commands are provided for interrupt processing.
		</p>
		<pre>
onkey goto/gosub *label          Specify key interrupt execution
onclick goto/gosub *label        Specify mouse click interrupt execution
oncmd goto/gosub *label,p1       Specify window message interrupt execution
onexit goto/gosub *label         Interrupt when the program ends
onerror goto/gosub *label        Interrupt when an error occurs

button goto/gosub "name",*label  Interrupt when a button is pressed</pre>
		<p>
			If you specify a label with the onkey command, from then on, every time a key is entered while the HSP window is active, it will jump to the label specified by *label
			(or subroutine jump).
			If you specify a label with the onclick command, from then on, every time a mouse
			click is performed on the HSP window, it will jump to the label specified by *label
			(or subroutine jump).
			The oncmd command is for setting the processing when a specific message is notified to the window. (See the reference for details.)
		</p>
		<p>
			The button command can also be considered as one of the interrupt settings.
			You can set the processing when the placed button is pressed.
		</p>
		<p>
			The onexit command sets the processing when the program is
			interrupted by the close box or [Alt]+[F4].
		</p>
		<p>
			The onerror command sets the processing when an error occurs internally in HSP due to a script.
			Even if you specify the processing after an error with the onerror command,
			after the necessary processing is completed, do not resume execution of the application as is,
			but end it with the end command as much as possible.
			The onerror command does not recover from errors.
			Depending on the cause of the error, the HSP system itself may become unstable or
			a failure may occur.
			The onerror command can be used when you want to display your own error message on the application side when an error occurs when creating an executable file,
			or when you want to display debugging information only when a specific error occurs.
		</p>
		<p>
			When an interrupt jump (interrupt without using on??? gosub) occurs, the subroutine and repeat〜loop nesting are all reset to 0 (initial state). If an interrupt jump occurs within a subroutine, please return program control to the main side.
		</p>
		<p>
			Interrupts from key or mouse input are only accepted when the script is stopped by the stop, wait, or await command. Also, after performing a jump due to an interrupt, the following system variables are set.
		</p>
		<table class="keywordlist" summary="Explains the relationship between interrupt factors and the system variables that are set.">
			<tr><th>Interrupt Factor</th><th>iparam</th><th>wparam</th><th>lparam</th></tr>
			<tr><td>onkey</td><td>Character Code</td><td>wParam</td><td>lParam</td></tr>
			<tr><td>onclick</td><td>Mouse Button ID</td><td>wParam</td><td>lParam</td></tr>
			<tr><td>oncmd</td><td>Message ID</td><td>wParam</td><td>lParam</td></tr>
			<tr><td>onexit</td><td>Termination Reason</td><td>Window ID</td><td>lParam</td></tr>
			<tr><td>onerror</td><td>0 (None)</td><td>Error Number</td><td>Error Line Number</td></tr>
		</table>
		<p>
			The system variable iparam is assigned a parameter for each interrupt factor. Also, wparam and lparam store the parameters passed as Windows messages as they are.
		</p>
		<p>
			It is also possible to temporarily turn ON/OFF event interrupt execution.
		</p>
		<pre>onkey 0</pre>
		<p>
			temporarily stops key interrupts.
		</p>
		<pre>onkey 1</pre>
		<p>
			can restart the temporarily stopped key interrupt. Similarly,
		</p>
		<pre>onclick 0 / onclick 1 / onerror 0 / onerror 1 / onexit 0 / onexit 1</pre>
		<p>
			can also be used.
		</p>
		<p>
			The onexit command also executes interrupt processing during Windows shutdown (restart, power off, etc.). This allows you to detect and perform appropriate termination processing even if a shutdown occurs while the script is running, but there are the following restrictions, so please keep them in mind when creating scripts that determine the termination time.
		</p>
		<p>
			Immediately after a jump with onexit, the system variable iparam stores the termination reason as a value.
			iparam = 0 means the program was terminated by the user.
		    iparam = 1 means the termination was due to a Windows shutdown.
		</p>
		<p>
			For termination processing during Windows shutdown, if you generate idle time (wait time) in the system with await, wait, or stop commands, the shutdown process will be aborted (it will not shut down). If you terminate with the end command without using await, wait, or stop commands, the shutdown process will continue as is.
		</p>
		<p>
			If you want to perform termination processing without aborting the shutdown process, you cannot use commands that generate wait time (such as await, wait, stop commands). (However, common dialogs (dialog command) etc. can be used.) Please perform only the minimum termination processing and terminate as is.
		</p>


		<h3 id="STANDARD_MODNAME">Standard Module Name</h3>
		<p>
			Standard keywords used by HSP in the system are assigned to the space of the module name "@hsp". This means that, for example, the official name of the mes command is "mes@hsp". However, the name without "@hsp" is also registered as an alias so that it can be used in the normal global space, so you can continue to use the command names as they are.
		</p>
		<p>
			For example, in the case of the mes command, it is the same as "#define global mes mes@hsp" being defined from the beginning. (After preprocessor processing, standard keywords are expanded to the official name with "@hsp" attached. You can see this by opening "hsptmp.i" which is output during compilation.)
		</p>
		<p>
			This allows you to alias the name itself registered as a standard keyword, or redefine it. The following is an example of replacing the mes command with a macro.
		</p>
		<pre>; Example
#undef mes
#define mes(%1) mes@hsp "MES-&gt;"+%1
    mes "Message."
    stop</pre>
		<p>
			The keyword "mes" is undefined using the #undef command and then redefined. All standard keywords used in HSP can be similarly undefined and redefined. The following is an example of replacing the mes command with a user-defined command.
		</p>
		<pre>; Example
#undef mes
#module
#deffunc mes str _p1
    _x = ginfo_cx : _y = ginfo_cy
    pos _x+1,_y+1
    color 0,0,0
    mes@hsp _p1
    pos _x,_y
    color 0,192,255
    mes@hsp _p1
    return
#global
    mes "I tried to make the mes command a shadowed character."
    stop</pre>
		<p>
			Please note that redefining standard keywords will affect all keywords after that.
		</p>


		<h3 id="COMMON_DIR">Common Directory</h3>
		<p>
			Files inserted by the "#use", "#include", and "#addition" commands are usually those in the same (current) directory as the source file, but if they are not there, those in the common directory are used.
		</p>
		<p>
			The common directory is named "common" and is located in the same directory as HSED3.EXE and HSP3.EXE. For example, if HSED3.EXE is in the directory "c:\hsp" and you are editing a script named "test.as" in the directory "c:\script", the order in which files are searched by the "#use", "#include", and "#addition" commands is as follows:
		</p>
		<ol>
			<li>Search for files in "c:\script"</li>
			<li>If not found, search for files in "c:\hsp\common"</li>
			<li>If still not found, an error occurs</li>
		</ol>
		<p>
			Files for using extended plugins (such as hspext.as) are all located in the common directory. Also, frequently used files such as hsp3util.as are also stored there.
		</p>


		<h3 id="ERR_MSG">Error Message</h3>
		<p>
			If HSP finds an error during execution due to a script writing mistake or a specification error, the error code and error line number will be displayed. For details, please see <a href="error.htm">Error Message List</a>.
		</p>

		<h3 id="TOLERANCE_LEVEL">Tolerance Range of the HSP System</h3>
		<p>
			The tolerance range of system resources in the current version is as follows. If this value is exceeded, normal operation cannot be guaranteed.
		</p>
		<table summary="Introduces the tolerance range of system resources in a list format." class="keywordlist">
			<caption>Tolerance Range of System Resources List</caption>
			<tr><td>Maximum Size of Source File (.AS)</td><td>Unlimited</td></tr>
			<tr><td>Maximum Size of Object File (.AX)</td><td>Unlimited</td></tr>

			<tr><td>Maximum Number of Labels that can be Declared</td><td>Unlimited</td></tr>
			<tr><td>Maximum Number of Variables that can be Declared</td><td>Unlimited</td></tr>
			<tr><td>Maximum Number of Characters in Identified Labels/Variables</td><td>59 characters (single-byte)</td></tr>
			<tr><td>Maximum String that can be Used in a Command</td><td>Unlimited</td></tr>
			<tr><td>Maximum String that can be Held in a Variable</td><td>Unlimited (as long as memory allows)</td></tr>
			<tr><td>Maximum Array that can be Held in a Variable</td><td>Unlimited (but up to 4 dimensions)</td></tr>

			<tr><td>Maximum Number of Plugins that can be Defined</td><td>Up to a total of 8192 types</td></tr>
			<tr><td>Maximum Number of Commands that can be Extended with Plugins</td><td>Up to 65536 per type</td></tr>
			<tr><td>Maximum Number of Modules that can be Defined</td><td>Unlimited</td></tr>
			<tr><td>Maximum Number of User-Defined Commands within a Module</td><td>Unlimited</td></tr>
			<tr><td>Maximum Number of Interrupts that can be Defined with the oncmd Command</td><td>Unlimited</td></tr>

			<tr><td>Maximum Number of Window IDs</td><td>Unlimited</td></tr>
			<tr><td>Number of Objects on 1 Screen</td><td>16384 (Warning at 1024)</td></tr>
			<tr><td>Maximum Size of Window that can be Displayed</td><td>Unlimited (as long as memory allows)</td></tr>
			<tr><td>Maximum Size of Image that can be Displayed</td><td>Unlimited</td></tr>
		</table>


		<h3 id="PACKFILE">File Packing and Encryption</h3>
		<p>
			In HSP, when creating an executable file, it is possible to collectively embed files such as images and audio that are read from the script into one file or executable file (.exe). This is called file packing, and it can prevent external users from viewing or referencing the files.
		</p>
		<p>
			With file packing, you can specify an unlimited number of files. You can express hierarchies by separating them with "\" or "/". File names, including folder names and extensions, are identified up to 259 characters.
		</p>
		<p>
			The easiest way to pack files into an executable file is to write the #packdir and #epackdir commands in the script.
		</p>

		<pre>
		#packdir "filename"
		#epackdir "filename"

		"filename" : File to be packed
		</pre>
		<p>
		Specifies the file to be packed. The specified file will be embedded in the executable file by automatic executable file creation (ctrl+F9). #packdir packs in normal format. In the case of #epackdir, it is encrypted and packed.
		</p>
		<pre>
		Example :
			#epackdir "a.bmp"
		</pre>
		<p>
		In the above example, the file "a.bmp" in the same folder as the script is encrypted and packed together with the executable file. (If it is not in the folder, the standard material folder (hsptv folder) will be searched)
		</p>
		<pre>
		Example :
			#packdir "data/*"
		</pre>
		<p>
		Wildcard characters using the "*" symbol are allowed in file names. If "data/*" is specified as above, all files under the data folder will be packed. Also, by specifying "*.png", you can pack all files with the extension ".png".
		</p>
		<p>
			It is also possible to save it as an independent single file instead of packing and embedding it in an executable file. This independent file is called a DPM file and has the extension ".dpm".
		<br>
			To create a DPM file, select "Tools" -> "Create DPM from Specified Folder" from the script editor menu to launch the tool.
		</p>
		<p><center><img src="img/packmakelist.png"></center></p>
		<p>
			This tool allows you to list the files in a specified folder and save them as a DPM file. (It can also be pasted into the script editor as a listing of #packdir or #epackdir.)
		</p>
		<ol>
			<li>Create a new program (setting) name.</li>
			<li>Specify the folder containing the data files as the search folder.</li>
			<li>Register the necessary types in the extension list on the left (e.g., png, wav, jpg).</li>
			<li>Press the "Create List" button to list the files to be packed in the box below.</li>
			<li>You can save the packed file with the "Create DPM File" button. (You can also paste the list directly into the script editor.)</li>
		</ol>
		<p>
			By default, a file named "data.dpm" is created. This file is automatically loaded if it exists in the current directory at runtime.
		</p>
		<p>
			When creating an executable file, the search order for files to be loaded is as follows:
		</p>
		<ol>
			<li>Files packed into the executable file.</li>
			<li>Files packed into "data.dpm" located in the same location as the executable file.</li>
			<li>Files in the current directory.</li>
			<li>Files in the standard material folder (hsptv folder) (only when running from the editor).</li>
		</ol>
		<p>
			Encryption can be applied when packing.
			This makes it difficult to analyze the executable file or DPM file.
			There are several ways to handle encrypted files,
			and the difficulty of analysis varies.
		</p>
		<dl>
			<dt>Encrypt and pack into the executable file</dt>
			<dd>
				<p>
					Encryption is performed using an encryption key generated based on the contents to be packed. This is the standard method.
				</p>
			</dd>
			<dt>Encrypt and pack into the DPM file</dt>
			<dd>
				<p>
					Creates a DPM file with an individual encryption key set.
					The created DPM file cannot be opened correctly unless the key code (32-bit value) used for encryption is specified from the script. (Refer to the help for the chdpm command for key code specification.)
					Since the encryption key is held within the script, analysis is difficult,
					and security is higher than when packing into an executable file.
					Creating DPM files with encryption key settings can be done on the DPM creation tool.
				</p>
			</dd>
		</dl>
		<p>
			The files packed into the executable file or .dpm are limited to files loaded by HSP.
			Please note that you cannot embed files loaded by Windows using the mci command, or files loaded by external tools or plugins.
		</p>
		<p>
			From HSP3.7, the format of the data packed and embedded has been changed to a new format called DPM2.
			As a result, it is no longer compatible with .dpm files up to HSP3.6. Please recreate previously created .dpm files.<br>
			HSP3.7 allows you to use multiple .dpm files simultaneously.
			To refer to a .dpm file, use the chdpm command.
		</p>
		<pre>
		chdpm "dpmname",p1,p2

		"dpmname" : DPM file name
		p1(-1)    : Encryption key specification
		p2(-1)    : Slot number (0-15)
		</pre>
		<p>
			Sets the .dpm file (data file with multiple files packed) to be loaded.<br>
			When the chdpm command is executed, the file specified by "dpmname" is treated as data packed in DPM format from then on.
			If an error occurs during the initialization of the DPM file, error 12 ("File not found or invalid name") will occur.
			<br><br>
			The slot number is the number to which the DPM file is loaded. You can specify a value from 0 to 15. If you specify a negative value, a new slot number will be automatically assigned.
			This allows you to refer to and load multiple DPM format files simultaneously.
			Files embedded in the exe file have a slot number of 0.
			If you specify an empty string ("") for the DPM file name, the specified slot number will be discarded from the loading target.
		</p>
		<p>
			The encryption function provided by HSP does not necessarily guarantee complete security.
			If a problem is discovered or a security hole is found, we will continue to respond appropriately in the future.
			We also plan to continue addressing file analysis and tampering.
		</p>
		<p>
		Please be aware of the following points when using DPM files and packed embedded files.
		</p>
		<ul>
		<li>You can use full-width characters including Japanese in file names, but they are stored internally as UTF8 strings. Therefore, on Windows, conversion from SJIS to Unicode will be performed. Please note that strings unique to SJIS or Unicode will not be converted correctly.
		<li>The length of the file name is "up to 259 characters including the folder name and extension." Full-width characters are also counted as 1 character.
		<li>Windows version DPM files support a maximum of 2GB per file and 4GB total size. Future versions will support even larger sizes.
		<li>You can load Windows version DPM files on Linux, android, iOS, and html5 (js). However, encryption is only supported in the android version in the current version.
		</ul>
		<p>
		When a "data.dpm" file is placed in the current directory, the files stored there will be prioritized when loading.
		Please be careful not to cause a situation where the correct file is not loaded or updated.
		</p>

		<h3 id="CNVSRC">Converting to C Source</h3>
		<p>
			You can convert HSP3 scripts into a form that can be compiled as source code for the C/C++ language.<br>
			This is done by calling the HSP3 source converter (hsp3cnv).
			Normally, select "Tools" -> "HSP3Dish / C Source Conversion" from the HSP script editor menu to call the support tool (HSP3Dish Helper).
		</p>
		<p>
			Knowledge of the C/C++ language is required for the operation of the converted C source code. For more information, please see the <a href="hsp3cnv.txt">HSP3 Source Converter Manual</a>.
		</p>

		<h3 id="BOOTOPT">About Using Startup Settings #bootopt</h3>
		<p>
		A new preprocessor directive, #bootopt, has been added.
		This is for fine-tuning runtime behavior settings.
		You can change the settings using the following format.
		</p>
		<pre>
		#bootopt OptionName  SettingSwitch

		OptionName : Type of option
		SettingSwitch : Numeric value of 1 or 0
		</pre>
		<p>
		Fine-tunes the script runtime behavior.
		Enter a space or TAB after OptionName, and then a numerical setting switch of 1 or 0.
		#bootopt can be written anywhere in the script.
		If there are multiple specifications, the last set value will be the overall setting.
		The option names that can be specified with #bootopt are as follows.
		</p>
		<pre>
		  Option   |      Content                  | Initial Value
		 -----------------------------------------------------------
		  notimer    | Use of high-precision timer        | Automatic setting
		             | (0=Use/1=Do not use)              |
		  utf8       | Use of UTF-8 format strings        | Automatic setting
		             | (0=Use/1=Do not use)              |
		  hsp64      | Use of 64-bit runtime            | Automatic setting
		             | (0=Use/1=Do not use)              |
		 -----------------------------------------------------------
		</pre>
		<p>
		Normally, these settings are done automatically.
		"Use of high-precision timer" is a setting for using a high-precision timer (multimedia timer) in the standard HSP runtime.<br>
		In HSP3.4, the high-precision timer was used to adjust the waiting time of await commands, etc., during the execution of all scripts,
		but the CPU load increased in tools and resident applications that did not require such strict timer control.
		In HSP3.5 and later, the high-precision timer is only used when the await command is used in the script.<br>
		You can use the #bootopt command to explicitly turn ON/OFF the use of the high-precision timer.
		If you write "#bootopt notimer 1" in the script, the high-precision timer will not be used.
		</p>

		<h3 id="CALLBACK">Callback Routine</h3>
		<p>
			A callback routine refers to one that needs to be terminated immediately with a return command in limited situations such as during interrupts.<br>
			Labels or user-defined commands that are called in the following situations are treated as callback routines.
		</p>
		<pre class="quote">
	・When executing cleanup commands defined by the #deffunc command
	・When executing constructors and destructors of module-type variables
	・User interrupts by placement objects (objlayer)
	・Sprite display interrupts by es_setgosub command (HSP3Dish)</pre>
		<p>
		Callback routines can be written in the same way as normal subroutines, but
		they cannot wait or stop for time.
		The following commands cannot be used in callback routines.
		</p>
		<pre class="quote">
	Commands that wait for time such as wait, await, stop, etc.
	The run command that migrates processing to another program
	Commands that execute system tasks such as screen, bgscr, etc.</pre>
		<p>
		When a callback routine is executed, the task must be returned to a separate system unlike usual,
		which causes these restrictions.<br>
		In a callback routine, execute only the necessary processing as much as possible,
		and immediately terminate the task with the return command.
		If there is a command that cannot be used during the execution of a callback routine,
		error 42 (command cannot be used in callback) will occur.
		</p>
		<!-- Footer -->
		<ul id="FOOTER">
			<li><a href="#CONTAINER">Return to the top of this page</a></li>
			<li><a href="../index.htm">Return to the document list</a></li>
			<li><a href="https://hsp.tv/">Go to HSPTV page</a></li>
		</ul>
		<a href="https://www.onionsoft.net/hsp/">
			<img src="img/onibtn.gif" width="147" height="50" alt="ONION software" id="ONIBTN">
		</a>
	</div><!-- container -->
</body>
</html>
